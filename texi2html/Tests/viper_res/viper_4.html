<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on a sunny day by texi2html -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Viper Is a Package for Emacs Rebels: 3. Customization</title>

<meta name="description" content="Viper Is a Package for Emacs Rebels: 3. Customization">
<meta name="keywords" content="Viper Is a Package for Emacs Rebels: 3. Customization">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Customization"></a>
<a name="SEC25"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="viper_3.html#SEC24" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC26" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="viper_3.html#SEC14" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="viper.html#Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="viper_5.html#SEC31" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="viper.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="viper_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="viper_7.html#SEC51" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="viper_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 3. Customization </h1>


<p>Customization can be done in 2 ways.
</p>
<ul>
<li>
<a name="IDX129"></a>
<a name="IDX130"></a>
Elisp code in a <tt>`.viper'</tt> file in your home directory.  Viper
loads <tt>`.viper'</tt> just before it does the binding for mode
hooks.  This is recommended for experts only.
</li><li>
<a name="IDX131"></a>
Elisp code in your <tt>`.emacs'</tt> file before and after the <code>(require
'viper)</code> line.  This method is <em>not</em> recommended, unless you know what
you are doing.  Only two variables, <code>viper-mode</code> and
<code>viper-custom-file-name</code>, are supposed to be customized in <tt>`.emacs'</tt>,
prior to loading Viper (i.e., prior to <code>(require 'viper)</code> command.
</li><li>
<a name="IDX132"></a>
By executing the <kbd>:customize</kbd> Ex command. This takes you to the Emacs
customization widget, which lets you change the values of Viper
customizable variables easily. This method is good for novice and
experts alike. The customization code in the form of Lisp commands will be
placed in <tt>`~/.emacs'</tt> or some other customization file depending on the
version of Emacs that you use. Still, it is recommended to separate
Viper-related customization produced by the Emacs customization widget
and keep it in the <tt>`.viper'</tt> file.

<p>Some advanced customization cannot be accomplished this way, however, and
has to be done in Emacs Lisp in the <tt>`.viper'</tt> file.  For the common
cases, examples are provided that you can use directly.
</p></li></ul>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC26">3.1 Rudimentary Changes</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">          Simple constant definitions.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC27">3.2 Key Bindings</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                 Enabling Emacs Keys, Rebinding keys, etc.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC28">3.2.1 Packages that Change Keymaps</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"> How to deal with such beasts.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC29">3.3 Viper Specials</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">               Special Viper commands.
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC30">3.4 Vi Macros</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                    How to do Vi style macros.
</td></tr>
</table>

<hr size="6">
<a name="Rudimentary-Changes"></a>
<a name="SEC26"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC25" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC27" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC25" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC25" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="viper_5.html#SEC31" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="viper.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="viper_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="viper_7.html#SEC51" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="viper_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.1 Rudimentary Changes </h2>


<p>An easy way to customize Viper is to change the values of constants used in
Viper.  Here is the list of the constants used in Viper and their default
values.  The corresponding :se command is also indicated.  (The symbols
<code>t</code> and <code>nil</code> represent &quot;true&quot; and &quot;false&quot; in Lisp).
</p>
<p>Viper supports both the abbreviated Vi variable names and their full
names.  Variable completion is done on full names only.  <kbd>TAB</kbd> and
<kbd>SPC</kbd> complete
variable names.  Typing `=' will complete the name and then will prompt for
a value, if applicable.  For instance, <kbd>:se au <kbd>SPC</kbd></kbd> will complete the
command to <kbd>:set autoindent</kbd>; <kbd>:se ta <kbd>SPC</kbd></kbd> will complete the command
and prompt further like this: <kbd>:set tabstop = </kbd>.
However, typing <kbd>:se ts <kbd>SPC</kbd></kbd> will produce a &quot;No match&quot; message
because <kbd>ts</kbd> is an abbreviation for <kbd>tabstop</kbd> and Viper supports
completion on full names only.  However, you can still hit <kbd>RET</kbd>
or <kbd>=</kbd>, which will complete the command like this: <kbd>:set ts = </kbd> and
Viper will be waiting for you to type a value for the tabstop variable.
To get the full list of Vi variables, type <kbd>:se <kbd>SPC</kbd> <kbd>TAB</kbd></kbd>.
</p>
<dl compact="compact">
<dt> <code>viper-auto-indent nil</code></dt>
<dt> <code>:se ai (:se autoindent)</code></dt>
<dt> <code>:se ai-g (:se autoindent-global)</code></dt>
<dd><p>If <code>t</code>, enable auto indentation.
by <kbd>RET</kbd>, <kbd>o</kbd> or <kbd>O</kbd> command.
</p>
<p><code>viper-auto-indent</code> is a local variable.  To change the value globally, use
<code>setq-default</code>.  It may be useful for certain major modes to have their
own values of <code>viper-auto-indent</code>.  This can be achieved by using
<code>setq</code> to change the local value of this variable in the hooks to the
appropriate major modes.
</p>
<p><kbd>:se ai</kbd> changes the value of <code>viper-auto-indent</code> in the current
buffer only; <kbd>:se ai-g</kbd> does the same globally.
</p></dd>
<dt> <code>viper-electric-mode t</code></dt>
<dd><p>If not <code>nil</code>, auto-indentation becomes electric, which means that
<kbd>RET</kbd>, <kbd>O</kbd>, and <kbd>o</kbd> indent cursor according to the current
major mode.  In the future, this variable may control additional electric
features.
</p>
<p>This is a local variable: <code>setq</code> changes the value of this variable
in the current buffer only.  Use <code>setq-default</code> to change the value in
all buffers.
</p></dd>
<dt> <code>viper-case-fold-search nil</code></dt>
<dt> <code>:se ic (:se ignorecase)</code></dt>
<dd><p>If not <code>nil</code>, search ignores cases.
This can also be toggled by quickly hitting <kbd>/</kbd> twice.
</p></dd>
<dt> <code>viper-re-search nil</code></dt>
<dt> <code>:se magic</code></dt>
<dd><p>If not <code>nil</code>, search will use regular expressions; if <code>nil</code> then
use vanilla search.
This behavior can also be toggled by quickly hitting <kbd>/</kbd> trice.
</p></dd>
<dt> <code>buffer-read-only</code></dt>
<dt> <code>:se ro (:se readonly)</code></dt>
<dd><p>Set current buffer to read only.  To change globally put
<code>(setq-default buffer-read-only t)</code> in your <tt>`.emacs'</tt> file.
</p></dd>
<dt> <code>blink-matching-paren t</code></dt>
<dt> <code>:se sm (:se showmatch)</code></dt>
<dd><p>Show matching parens by blinking cursor.
</p></dd>
<dt> <code>tab-width t (default setting via <code>setq-default</code>)</code></dt>
<dt> <code>:se ts=value (:se tabstop=value)</code></dt>
<dt> <code>:se ts-g=value (:se tabstop-global=value)</code></dt>
<dd><p><code>tab-width</code> is a local variable that controls the width of the tab stops.
To change the value globally, use <code>setq-default</code>; for local settings,
use <code>setq</code>.
</p>
<p>The command <kbd>:se ts</kbd>
sets the tab width in the current
buffer only; it has no effect on other buffers.
</p>
<p>The command <kbd>:se ts-g</kbd> sets tab width globally,
for all buffers where the tab is not yet set locally,
including the new buffers.
</p>
<p>Note that typing <kbd>TAB</kbd> normally
doesn't insert the tab, since this key is usually bound to
a text-formatting function, <code>indent-for-tab-command</code> (which facilitates
programming and document writing).  Instead, the tab is inserted via the
command <code>viper-insert-tab</code>, which is bound to <kbd>S-tab</kbd> (shift + tab).
</p>
<p>On some non-windowing terminals, Shift doesn't modify the <kbd>TAB</kbd> key, so
<kbd>S-tab</kbd> behaves as if it were <kbd>TAB</kbd>.  In such a case, you will have
to bind <code>viper-insert-tab</code> to some other convenient key.
</p>
</dd>
<dt> <code>viper-shift-width 8</code></dt>
<dt> <code>:se sw=value  (:se shiftwidth=value)</code></dt>
<dd><p>The number of columns shifted by <kbd>&gt;</kbd> and <kbd>&lt;</kbd> commands.
</p></dd>
<dt> <code>viper-search-wrap-around t</code></dt>
<dt> <code>:se ws (:se wrapscan)</code></dt>
<dd><p>If not <code>nil</code>, search wraps around the end/beginning of buffer.
</p></dd>
<dt> <code>viper-search-scroll-threshold 2</code></dt>
<dd><p>If search lands within this many lines of the window top or bottom, the
window will be scrolled up or down by about 1/7-th of its size, to reveal
the context.  If the value is negative--don't scroll.
</p></dd>
<dt> <code>viper-tags-file-name &quot;TAGS&quot;</code></dt>
<dd><p>The name of the file used as the tag table.
</p></dd>
<dt> <code>viper-re-query-replace nil</code></dt>
<dd><p>If not <code>nil</code>, use reg-exp replace in query replace.
</p></dd>
<dt> <code>viper-want-ctl-h-help nil</code></dt>
<dd><p>If not <code>nil</code>, <kbd>C-h</kbd> is bound to <code>help-command</code>;
otherwise, <kbd>C-h</kbd> is bound as usual in Vi.
</p></dd>
<dt> <code>viper-vi-style-in-minibuffer t</code></dt>
<dd><p>If not <code>nil</code>, Viper provides a high degree of compatibility with Vi
insert mode when you type text in the Minibuffer; if <code>nil</code>, typing in
the Minibuffer feels like plain Emacs.
</p></dd>
<dt> <code>viper-no-multiple-ESC t</code></dt>
<dd><p>If you set this to <code>nil</code>, you can use <kbd>ESC</kbd> as Meta in Vi state.
Normally, this is not necessary, since graphical displays have separate
Meta keys (usually on each side of the space bar).  On a dumb terminal, Viper
sets this variable to <code>twice</code>, which is almost like <code>nil</code>, except
that double <kbd>ESC</kbd> beeps.  This, too, lets <kbd>ESC</kbd> to be used as a Meta.
</p></dd>
<dt> <code>viper-ESC-keyseq-timeout 200 on tty, 0 on windowing display</code></dt>
<dd><p>Escape key sequences separated by this much delay (in milliseconds) are
interpreted as command, ignoring the special meaning of <kbd>ESC</kbd> in
VI.  The default is suitable for most terminals.  However, if your terminal
is extremely slow, you might want to increase this slightly.  You will know
if your terminal is slow if the <kbd>ESC</kbd> key sequences emitted by the
arrow keys are interpreted as separately typed characters (and thus the
arrow keys won't work).  Making this value too large will slow you down, so
exercise restraint.
</p></dd>
<dt> <code>viper-fast-keyseq-timeout 200</code></dt>
<dd><p>Key sequences separated by this many milliseconds are treated as Vi-style
keyboard macros.  If the key sequence is defined as such a macro, it will be
executed.  Otherwise, it is processed as an ordinary sequence of typed keys.
</p>
<p>Setting this variable too high may slow down your typing.  Setting it too
low may make it hard to type macros quickly enough.
</p></dd>
<dt> <code>viper-translate-all-ESC-keysequences t on tty, nil on windowing display</code></dt>
<dd><p>Normally, Viper lets Emacs translate only those ESC key sequences that are
defined in the low-level key-translation-map or function-key-map, such as those
emitted by the arrow and function keys. Other sequences, e.g., <kbd>\\e/</kbd>, are
treated as <kbd>ESC</kbd> command followed by a <kbd>/</kbd>. This is good for people
who type fast and tend to hit other characters right after they hit
ESC. Other people like Emacs to translate <kbd>ESC</kbd> sequences all the time. 
The default is to translate all sequences only when using a dumb terminal.
This permits you to use <kbd>ESC</kbd> as a meta key in insert mode. For instance,
hitting <kbd>ESC x</kbd> fast would have the effect of typing <kbd>M-x</kbd>.
If your dumb terminal is not so dumb and understands the meta key, then you
probably will be better off setting this variable to nil. Try and see which
way suits you best.
</p></dd>
<dt> <code>viper-ex-style-motion t</code></dt>
<dd><p>Set this to <code>nil</code>, if you want <kbd>l,h</kbd> to cross
lines, etc.  See section <a href="viper_3.html#SEC22">Movement and Markers</a>, for more info.
</p></dd>
<dt> <code>viper-ex-style-editing t</code></dt>
<dd><p>Set this to <code>nil</code>, if you want
<kbd>C-h</kbd> and <kbd>DEL</kbd> to not stop
at the beginning of a line in Insert state, <kbd>X</kbd> and <kbd>x</kbd> to delete
characters across lines in Vi command state, etc.
</p></dd>
<dt> <code>viper-ESC-moves-cursor-back t</code></dt>
<dd><p>It t, cursor moves back 1 character when switching from insert state to vi
state.  If nil, the cursor stays where it was before the switch.
</p></dd>
<dt> <code>viper-always t</code></dt>
<dd><p><code>t</code> means: leave it to Viper to decide when a buffer must be brought
up in Vi state,
Insert state, or Emacs state.  This heuristics works well in virtually all
cases.  <code>nil</code> means you either has to invoke <code>viper-mode</code> manually
for each buffer (or you can add <code>viper-mode</code> to the appropriate major mode
hooks using <code>viper-load-hook</code>).
</p>
<p>This option must be set in the file <tt>`~/.viper'</tt>.
</p></dd>
<dt> <code>viper-custom-file-name &quot;~/.viper&quot;</code></dt>
<dd><p>File used for Viper-specific customization.
Change this setting, if you want.  Must be set in <tt>`.emacs'</tt> (not <tt>`.viper'</tt>!)
before Viper is loaded.  Note that you
have to set it as a string inside double quotes.
</p></dd>
<dt> <code>viper-spell-function 'ispell-region</code></dt>
<dd><p>Function used by the command <kbd>#c&lt;move&gt;</kbd> to spell.
</p></dd>
<dt> <code>viper-glob-function</code></dt>
<dd><p>The value of this variable is the function symbol used to expand wildcard
symbols. This is platform-dependent. The default tries to set this variable
to work with most shells, MS Windows, OS/2, etc. However, if it
doesn't work the way you expect, you should write your own.
Use <code>viper-glob-unix-files</code> and <code>viper-glob-mswindows-files</code> in
<tt>`viper-util.el'</tt> as examples.
</p>
<p>This feature is used to expand wildcards in the Ex command <kbd>:e</kbd>.
Note that Viper doesn't support wildcards in the <kbd>:r</kbd> and <kbd>:w</kbd>
commands, because file completion is a better mechanism.
<a name="IDX133"></a>
</p>
</dd>
<dt> <code>ex-cycle-other-window t</code></dt>
<dd><p>If not <code>nil</code>, <kbd>:n</kbd> and <kbd>:b</kbd> will cycle through files in another
window, if one exists.
</p></dd>
<dt> <code>ex-cycle-through-non-files nil</code></dt>
<dd><p><kbd>:n</kbd> does not normally cycle through buffers.  Set this to get
buffers also.
</p></dd>
<dt> <code>viper-want-emacs-keys-in-insert</code></dt>
<dd><p>This is set to <code>nil</code> for user levels 1 and 2 and to <code>t</code> for user
levels 3 and 4.  Users who specify level 5 are allowed to set this variable
as they please (the default for this level is <code>t</code>).  If set to
<code>nil</code>, complete Vi compatibility is provided in Insert state.  This is
really not recommended, as this precludes you from using language-specific
features provided by the major modes.
</p></dd>
<dt> <code>viper-want-emacs-keys-in-vi</code></dt>
<dd><p>This is set to <code>nil</code> for user
level 1 and to <code>t</code> for user levels 2-4.
At level 5, users are allowed to set this variable as they please (the
default for this level is <code>t</code>).
If set to <code>nil</code>, complete Vi compatibility is provided
in Vi command state.  Setting this to <code>nil</code> is really a bad idea,
unless you are a novice, as this precludes the use
of language-specific features provided by the major modes.
</p></dd>
<dt> <code>viper-keep-point-on-repeat t</code></dt>
<dd><p>If not <code>nil</code>, point is not moved when the user repeats the previous
command by typing `.'  This is very useful for doing repeated changes with
the <kbd>.</kbd> key.
</p></dd>
<dt> <code>viper-repeat-from-history-key 'f12</code></dt>
<dd><p>Prefix key used to invoke the macros <kbd>f12 1</kbd> and <kbd>f12 2</kbd> that repeat
the second-last and the third-last destructive command.
Both these macros are bound (as Viper macros) to
<code>viper-repeat-from-history</code>,
which checks the second key by which it is invoked to see which of the
previous commands to invoke.  Viper binds <kbd>f12 1</kbd> and <kbd>f12 2</kbd> only,
but the user can bind more in <tt>`~/.viper'</tt>.  See section <a href="#SEC30">Vi Macros</a>, for how to do
this.
</p></dd>
<dt> <code>viper-keep-point-on-undo nil</code></dt>
<dd><p>If not <code>nil</code>, Viper tries to not move point when undoing commands.
Instead, it will briefly move the cursor to the place where change has
taken place.  However, if the undone piece of text is not seen in window,
then point will be moved to the place where the change took place.
Set it to <code>t</code> and see if you like it better.
</p></dd>
<dt> <code>viper-delete-backwards-in-replace nil</code></dt>
<dd><p>If not <code>nil</code>, <kbd>DEL</kbd> key will delete characters while moving the cursor
backwards.  If <code>nil</code>, the cursor will move backwards without deleting
anything.
</p></dd>
<dt> <code>viper-replace-overlay-face 'viper-replace-overlay-face</code></dt>
<dd><p>On a graphical display, Viper highlights replacement regions instead of
putting a <samp>`$'</samp> at the end.  This variable controls the so called
<em>face</em> used to highlight the region.
</p>
<p>By default, <code>viper-replace-overlay-face</code> underlines the replacement on
monochrome displays and also lays a stipple over them.  On color displays,
replacement regions are highlighted with color.
</p>
<p>If you know something about Emacs faces and don't like how Viper highlights
replacement regions, you can change <code>viper-replace-overlay-face</code> by
specifying a new face.  (Emacs faces are described in the Emacs Lisp
reference.)  On a color display, the following customization method is
usually most effective:
</p><table><tr><td>&nbsp;</td><td><pre class="example">(set-face-foreground viper-replace-overlay-face &quot;DarkSlateBlue&quot;)
(set-face-background viper-replace-overlay-face &quot;yellow&quot;)
</pre></td></tr></table><p>For a complete list of colors available to you, evaluate the expression
<code>(x-defined-colors)</code>.  (Type it in the buffer <code>*scratch*</code> and then
hit the <kbd>C-j</kbd> key.
</p>
</dd>
<dt> <code>viper-replace-overlay-cursor-color  &quot;Red&quot;</code></dt>
<dd><a name="IDX134"></a>
<p>Cursor color when it is inside the replacement region.
This has effect only on color displays and only when Emacs runs as an X
application.
</p></dd>
<dt> <code>viper-insert-state-cursor-color nil</code></dt>
<dd><a name="IDX135"></a>
<p>If set to a valid color, this will be the cursor color when Viper is in
insert state.
</p></dd>
<dt> <code>viper-replace-region-end-delimiter &quot;$&quot;</code></dt>
<dd><p>A string used to mark the end of replacement regions.  It is used only on
TTYs or if <code>viper-use-replace-region-delimiters</code> is non-nil.
</p></dd>
<dt> <code>viper-replace-region-start-delimiter  &quot;&quot;</code></dt>
<dd><p>A string used to mark the beginning of replacement regions.  It is used
only on TTYs or if <code>viper-use-replace-region-delimiters</code> is non-nil.
</p></dd>
<dt> <code>viper-use-replace-region-delimiters</code></dt>
<dd><p>If non-nil, Viper will always use <code>viper-replace-region-end-delimiter</code> and
<code>viper-replace-region-start-delimiter</code> to delimit replacement regions,
even on color displays (where this is unnecessary).  By default, this
variable is non-nil only on TTYs or monochrome displays.
</p></dd>
<dt> <code>viper-allow-multiline-replace-regions t</code></dt>
<dd><p>If non-nil, multi-line text replacement regions, such as those produced by
commands <kbd>c55w</kbd>, <kbd>3C</kbd>, etc., will stay around until the user exits
the replacement mode.  In this variable is set to <code>nil</code>, Viper will
emulate the standard Vi behavior, which supports only intra-line
replacement regions (and multi-line replacement regions are deleted).
</p></dd>
<dt> <code>viper-toggle-key &quot;\C-z&quot;</code></dt>
<dd><p>Specifies the key used to switch from Emacs to Vi and back.
Must be set in <tt>`.viper'</tt>.  This variable can't be
changed interactively after Viper is loaded.
</p>
<p>In Insert state, this key acts as a temporary escape to Vi state, i.e., it
will set Viper up so that the very next command will be executed as if it
were typed in Vi state.
</p></dd>
<dt> <code>viper-ESC-key &quot;\e&quot;</code></dt>
<dd><p>Specifies the key used to escape from Insert/Replace states to Vi.
Must be set in <tt>`.viper'</tt>.  This variable cannot be
changed interactively after Viper is loaded.
</p></dd>
<dt> <code>viper-buffer-search-char nil</code></dt>
<dd><p>Key used for buffer search.  See section <a href="#SEC29">Viper Specials</a>, for details.
</p></dd>
<dt> <code>viper-surrounding-word-function 'viper-surrounding-word</code></dt>
<dd><p>The value of this variable is a function name that is used to determine
what constitutes a word clicked upon by the mouse.  This is used by mouse
search and insert.
</p></dd>
<dt> <code>viper-search-face 'viper-search-face</code></dt>
<dd><p>Variable that controls how search patterns are highlighted when they are
found.
</p></dd>
<dt> <code>viper-vi-state-hook nil</code></dt>
<dd><p>List of parameterless functions to be run just after entering the Vi
command state.
</p></dd>
<dt> <code>viper-insert-state-hook nil</code></dt>
<dd><p>Same for Insert state.  This hook is also run after entering Replace state.
</p></dd>
<dt> <code>viper-replace-state-hook  nil</code></dt>
<dd><p>List of (parameterless) functions called just after entering Replace state
(and after all <code>viper-insert-state-hook</code>).
</p></dd>
<dt> <code>viper-emacs-state-hook nil</code></dt>
<dd><p>List of (parameterless) functions called just after switching from Vi state
to Emacs state.
</p></dd>
<dt> <code>viper-load-hook nil</code></dt>
<dd><p>List of (parameterless) functions called just after loading Viper.  This is
the last chance to do customization before Viper is up and running.
</p></dd>
</dl>

<p>You can reset some of these constants in Viper with the Ex command <kbd>:set</kbd>
(when so indicated in the table).  Or you
can include a line like this in your <tt>`.viper'</tt> file:
</p><table><tr><td>&nbsp;</td><td><pre class="example">(setq viper-case-fold-search t)
</pre></td></tr></table><a name="IDX136"></a>
<a name="IDX137"></a>
<a name="IDX138"></a>
<a name="IDX139"></a>
<a name="IDX140"></a>
<a name="IDX141"></a>
<a name="IDX142"></a>
<a name="IDX143"></a>
<a name="IDX144"></a>
<a name="IDX145"></a>
<a name="IDX146"></a>
<a name="IDX147"></a>
<a name="IDX148"></a>
<a name="IDX149"></a>
<a name="IDX150"></a>
<a name="IDX151"></a>
<a name="IDX152"></a>
<a name="IDX153"></a>
<a name="IDX154"></a>
<a name="IDX155"></a>
<a name="IDX156"></a>
<a name="IDX157"></a>
<a name="IDX158"></a>
<a name="IDX159"></a>
<a name="IDX160"></a>
<a name="IDX161"></a>
<a name="IDX162"></a>
<a name="IDX163"></a>
<a name="IDX164"></a>
<a name="IDX165"></a>
<a name="IDX166"></a>
<a name="IDX167"></a>
<a name="IDX168"></a>
<a name="IDX169"></a>
<a name="IDX170"></a>
<a name="IDX171"></a>
<a name="IDX172"></a>
<a name="IDX173"></a>
<a name="IDX174"></a>
<a name="IDX175"></a>
<a name="IDX176"></a>

<hr size="6">
<a name="Key-Bindings"></a>
<a name="SEC27"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC26" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC28" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC25" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC25" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="viper_5.html#SEC31" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="viper.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="viper_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="viper_7.html#SEC51" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="viper_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.2 Key Bindings </h2>


<p>Viper lets you define hot keys, i.e., you can associate keyboard keys
such as F1, Help, PgDn, etc., with Emacs Lisp functions (that may already
exist or that you will write).  Each key has a &quot;preferred form&quot; in
Emacs.  For instance, the Up key's preferred form is [up], the Help key's
preferred form is [help], and the Undo key has the preferred form [f14].
You can find out the preferred form of a key by typing <kbd>M-x
describe-key-briefly</kbd> and then typing the key you want to know about.
</p>
<p>Under the X Window System, every keyboard key emits its preferred form,
so you can just type
</p>
<table><tr><td>&nbsp;</td><td><pre class="lisp">(global-set-key [f11] 'calendar)                        ; L1, Stop
(global-set-key [f14] 'undo)                            ; L4, Undo
</pre></td></tr></table>

<p>to bind L1 (a key that exists on some SUN workstations) so it will invoke
the Emacs Calendar and to bind L4 so it will undo changes.
However, on a dumb terminal or in an Xterm window, even the standard arrow
keys may
not emit the right signals for Emacs to understand.  To let Emacs know about
those keys, you will have to find out which key sequences they emit
by typing <kbd>C-q</kbd> and then the key (you should switch to Emacs state
first).  Then you can bind those sequences to their preferred forms using
<code>function-key-map</code> as follows:
</p>
<table><tr><td>&nbsp;</td><td><pre class="lisp">(cond ((string= (getenv &quot;TERM&quot;) &quot;xterm&quot;)
(define-key function-key-map &quot;\e[192z&quot; [f11])    ; L1
(define-key function-key-map &quot;\e[195z&quot; [f14])    ; L4, Undo
</pre></td></tr></table>
<p>The above illustrates how to do this for Xterm.  On VT100, you would have to
replace &quot;xterm&quot; with &quot;vt100&quot; and also change the key sequences (the same
key may emit different sequences on different types of terminals).
</p>
<p>The above keys are global, so they are overwritten by the local maps
defined by the major modes and by Viper itself.  Therefore, if you wish to
change a binding set by a major mode or by Viper, read this.
</p>
<p>Viper users who wish to specify their own key bindings should be concerned
only with the following three keymaps:
<code>viper-vi-global-user-map</code> for Vi state commands,
<code>viper-insert-global-user-map</code> for Insert state commands,
and <code>viper-emacs-global-user-map</code> for Emacs state commands (note:
customized bindings for Emacs state made to <code>viper-emacs-global-user-map</code>
are <em>not</em> inherited by Insert state).
</p>
<p>For more information on Viper keymaps, see the header of the file
<tt>`viper.el'</tt>.
If you wish to change a Viper binding, you can use the
<code>define-key</code> command, to modify <code>viper-vi-global-user-map</code>,
<code>viper-insert-global-user-map</code>, and <code>viper-emacs-global-user-map</code>, as
explained below.  Each of these key maps affects the corresponding Viper state.
The keymap <code>viper-insert-global-user-map</code> also affects Viper's Replace
state. 
</p>

<p>If you want to
bind a key, say <kbd>C-v</kbd>, to the function that scrolls
page down and to make <kbd>0</kbd> display information on the current buffer,
putting this in <tt>`.viper'</tt> will do the trick in Vi state:
</p><table><tr><td>&nbsp;</td><td><pre class="example">(define-key viper-vi-global-user-map &quot;\C-v&quot; 'scroll-down)
</pre></td></tr></table>
<p>To set a key globally,
</p><table><tr><td>&nbsp;</td><td><pre class="example">(define-key viper-emacs-global-user-map &quot;\C-c m&quot; 'smail)
(define-key viper-vi-global-user-map &quot;0&quot; 'viper-info-on-file)
</pre></td></tr></table>
<p>Note, however, that this binding may be overwritten by other keymaps, since
the global keymap has the lowest priority.
To make sure that nothing will override a binding in Emacs state, you
can write this:
</p><table><tr><td>&nbsp;</td><td><pre class="example">(define-key viper-emacs-global-user-map &quot;\C-c m&quot; 'smail)
</pre></td></tr></table>
<p>To customize the binding for <kbd>C-h</kbd> in Insert state:
</p><table><tr><td>&nbsp;</td><td><pre class="example">(define-key viper-insert-global-user-map &quot;\C-h&quot; 'my-del-backwards-function)
</pre></td></tr></table>

<p>Each Emacs command key calls some lisp function.  If you have enabled the
Help, (see section <a href="#SEC26">Rudimentary Changes</a>) <kbd>C-h k</kbd> will show you the function
for each specific key; <kbd>C-h b</kbd> will show all bindings, and <kbd>C-h m</kbd>
will provide information on the major mode in effect.  If Help is not
enabled, you can still get help in Vi state by prefixing the above commands
with <kbd>\</kbd>, e.g., <kbd>\ C-h k</kbd> (or you can use the Help menu in the
menu bar, if Emacs runs under X).
</p>
<p>Viper users can also change bindings on a per major mode basis.  As with
global bindings, this can be done separately for each of the three main Viper
states.  To this end, Viper provides the function
<code>viper-modify-major-mode</code>.
<a name="IDX177"></a>
</p>
<p>To modify keys in Emacs state for <code>my-favorite-major-mode</code>, the user
needs to create a sparse keymap, say, <code>my-fancy-map</code>, bind whatever
keys necessary in that keymap, and put
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(viper-modify-major-mode 'dired-mode 'emacs-state my-fancy-map)
</pre></td></tr></table>

<p>in <tt>`~/.viper'</tt>.  To do the same in Vi and Insert states, you should use
<code>vi-state</code> and <code>insert-state</code>.  Changes in Insert state are also
in effect in Replace state.  For instance, suppose that the user wants to
use <kbd>dd</kbd> in Vi state under Dired mode to delete files, <kbd>u</kbd> to unmark
files, etc.  The following code in <tt>`~/.viper'</tt> will then do the job:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(setq my-dired-modifier-map (make-sparse-keymap))
(define-key my-dired-modifier-map &quot;dd&quot; 'dired-flag-file-deletion)
(define-key my-dired-modifier-map &quot;u&quot; 'dired-unmark)
(viper-modify-major-mode 'dired-mode 'vi-state my-dired-modifier-map)
</pre></td></tr></table>
<p>A Vi purist may want to modify Emacs state under Dired mode so that
<kbd>k</kbd>, <kbd>l</kbd>, etc., will move around in directory buffers, as in
Vi.  Although this is not recommended, as these keys are bound to useful
Dired functions, the trick can be accomplished via the following code:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(setq my-dired-vi-purist-map (make-sparse-keymap))
(define-key my-dired-vi-purist-map &quot;k&quot; 'viper-previous-line)
(define-key my-dired-vi-purist-map &quot;l&quot; 'viper-forward-char)
(viper-modify-major-mode 'dired-mode 'emacs-state my-dired-vi-purist-map)
</pre></td></tr></table>
<p>Yet another way to customize key bindings in a major mode is to edit the
list <code>viper-major-mode-modifier-list</code> using the customization widget.
<a name="IDX178"></a>
(This variable is in the Viper-misc customization group.)
The elements of this list are triples of the form: (major-mode viper-state
keymap), where the keymap contains bindings that are supposed to be active
in the given major mode and the given viper-state.
</p>
<p>Effects similar to key binding changes can be achieved by defining Vi
keyboard macros using the Ex commands <kbd>:map</kbd> and <kbd>:map!</kbd>.  The
difference is that multi-key Vi macros do not override the keys they are
bound to, unless these keys are typed in quick succession.  So, with macros,
one can use the normal keys alongside with the macros.  If per-mode
modifications are needed, the user can try both ways and see which one is
more convenient.
<a name="IDX179"></a>
See section <a href="#SEC30">Vi Macros</a>, for details.
</p>
<p>Note: in major modes that come up in <em>Emacs state</em> by default, the
aforesaid modifications may not take place immediately (but only after the
buffer switches to some other Viper state and then back to Emacs state).  To
avoid this, one should add <code>viper-change-state-to-emacs</code> to an
appropriate hook of that major mode.  (Check the function
<code>viper-set-hooks</code> in <tt>`viper.el'</tt> for examples.)  However, if you
did not set <code>viper-always</code> to <code>nil</code>, chances are that you won't
need to perform the above procedure, because Viper will take care of most
useful defaults.
</p>

<p>Finally, Viper has a facility that lets the user define per-buffer
bindings, i.e., bindings that are in effect in some specific buffers
only.  Unlike per-mode bindings described above, per-buffer bindings can be
defined based on considerations other than the major mode.  This is done
via the function <code>viper-add-local-keys</code>, which lets one specify bindings
that should be in effect in the current buffer only and for a specific Viper
state.  For instance,
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(viper-add-local-keys 'vi-state '((&quot;ZZ&quot; . TeX-command-master)
                                 (&quot;ZQ&quot; . viper-save-kill-buffer)))
</pre></td></tr></table>
<p>redefines <kbd>ZZ</kbd> to invoke <code>TeX-command-master</code> in <code>vi-state</code>
and <kbd>ZQ</kbd> to save-then-kill the current buffer.  These bindings take
effect only in the buffer where this command is executed.  The typical use
of this function is to execute the above expression from within a function
that is included in a hook to some major mode.  For instance, the above
expression
could be called from a function, <code>my-tex-init</code>, which may be added to
<code>tex-mode-hook</code> as follows:
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(add-hook 'tex-mode-hook 'my-tex-init)
</pre></td></tr></table>
<p>When TeX mode starts, the hook is executed and the above Lisp expression is
evaluated.  Then, the bindings for <kbd>ZZ</kbd> and <kbd>ZQ</kbd> are changed in Vi
command mode for all buffers in TeX mode.
</p>
<p>Another useful application is to bind <kbd>ZZ</kbd> to <code>send-mail</code>
in the Mail mode buffers (the specifics of this depend on which mail
package you are using, <code>rmail</code>, <code>mh-e</code>, <code>vm</code>, etc.
For instance, here is how to do this for <code>mh-e</code>, the Emacs interface
to MH:
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(defun mh-add-vi-keys ()
  &quot;Set up ZZ for MH-e and XMH.&quot;
  (viper-add-local-keys 'vi-state '((&quot;ZZ&quot; . mh-send-letter))))
(add-hook 'mh-letter-mode-hook 'mh-add-vi-keys)
</pre></td></tr></table>
<p>You can also use <code>viper-add-local-keys</code> to set per buffer
bindings in Insert state and Emacs state by passing as a parameter the
symbols <code>insert-state</code> and <code>emacs-state</code>, respectively.
As with global bindings, customized local bindings done to Emacs state
are not inherited by Insert state.
</p>
<p>On rare occasions, local keys may be added by mistake.  Usually this is done
indirectly, by invoking a major mode that adds local keys (e.g.,
<code>shell-mode</code> redefines <kbd>RET</kbd>).  In such a case, exiting the wrong
major mode won't rid you from unwanted local keys, since these keys are
local to Viper state and the current buffer, not to the major mode.
In such situations, the remedy is to type <kbd>M-x viper-zap-local-keys</kbd>.
</p>
<p>So much about Viper-specific bindings.
See <a href="../emacs/Customization.html#Customization">(emacs)Customization</a> section `Customization' in <cite>The GNU Emacs Manual</cite>, and the Emacs quick reference card for the general info on key
bindings in Emacs.
</p>
<a name="IDX180"></a>
<a name="IDX181"></a>
<a name="IDX182"></a>
<a name="IDX183"></a>
<a name="IDX184"></a>
<a name="IDX185"></a>

<hr size="6">
<a name="Packages-that-Change-Keymaps"></a>
<a name="SEC28"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC27" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC29" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC25" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC27" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="viper_5.html#SEC31" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="viper.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="viper_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="viper_7.html#SEC51" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="viper_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 3.2.1 Packages that Change Keymaps </h3>

<p>Viper is designed to coexist with all major and minor modes of Emacs.  This
means that bindings set by those modes are generally available with Viper
(unless you explicitly prohibit them by setting
<code>viper-want-emacs-keys-in-vi</code> and <code>viper-want-emacs-keys-in-insert</code> to
<code>nil</code>).
If <code>viper-always</code> is set to <code>t</code> (which is the default), Viper
will try to bring each buffer 
in the Viper state that is most appropriate for that buffer.
Usually, this would be the Vi state, but sometimes it could be the Insert
state or the Emacs state.
</p>
<p>Some major mode bindings will necessarily be overwritten by Viper.  Indeed, in
Vi state, most of the 1-character keys are used for Vi-style editing.  This
usually causes no problems because most packages designed for editing files
typically do not bind such keys.  Instead, they use key sequences that start
with <kbd>C-x</kbd> and <kbd>C-c</kbd>.  This is why it was so important for us to
free up <kbd>C-x</kbd> and <kbd>C-c</kbd>.
It is common for language-specific major modes to bind <kbd>TAB</kbd> and
<kbd>C-j</kbd> (the line feed) keys to various formatting functions.  This is
extremely useful, but may require some getting used to for a Vi user.  If you
decide that this feature is not for you, you can re-bind these keys as
explained earlier (see section <a href="#SEC25">Customization</a>).
</p>
<p>Binding for <kbd>TAB</kbd> is one of the most unusual aspects of Viper for many
novice users.  In Emacs, <kbd>TAB</kbd> is used to format text and programs, and
is extremely useful.  For instance, hitting <kbd>TAB</kbd> causes the current
line to be re-indented in accordance with the context.  In programming,
this is very important, since improper automatic indentation would
immediately alert the programmer to a possible error.  For instance, if a
<kbd>)</kbd> or a <kbd>&quot;</kbd> is missing somewhere above the current
line, <kbd>TAB</kbd> is likely to mis-indent the line.
</p>
<p>For this reason, Viper doesn't change the standard Emacs binding of
<kbd>TAB</kbd>, thereby sacrificing Vi compatibility
(except for users at level 1).  Instead, in Viper, the key
<kbd>S-tab</kbd> (shift+ tab) is chosen to emulate Vi's <kbd>TAB</kbd>.
</p>
<p>We should note that on some non-windowing terminals, Shift doesn't modify
the <kbd>TAB</kbd> key, so <kbd>S-tab</kbd> behaves as if it were <kbd>TAB</kbd>.  In such
a case, you will have to bind <code>viper-insert-tab</code> to some other
convenient key.
</p>
<p>Some packages, notably Dired, Gnus, Info, etc., attach special meaning to
common keys like <kbd>SPC</kbd>, <kbd>x</kbd>, <kbd>d</kbd>, <kbd>v</kbd>, and others.  This
means that Vi command state is inappropriate for working with these
packages.  Fortunately, these modes operate on read-only buffers and are
designed not for editing files, but for special-purpose browsing, reading
news, mail, etc., and Vi commands are meaningless in these situations.  For
this reason, Viper doesn't force Vi state on such major modes--it
brings them in Emacs state.  You can switch to Vi state by typing <kbd>C-z</kbd>
if, for instance, you want to do Vi-style search in a buffer (although,
usually, incremental search, which is bound to <kbd>C-s</kbd>, is sufficient in
these situations).  But you should then switch back to Emacs state if you
plan to continue using these major modes productively.  You can also switch
to Vi temporarily, to execute just one command.  This is done by typing
<kbd>C-c \</kbd>.  (In some of these modes, <kbd>/</kbd> and <kbd>:</kbd> are bound
Vi-style, unless these keys perform essential duties.)
</p>
<p>If you would like certain major modes to come up in Emacs state rather than
Vi state (but Viper thinks otherwise), you should put these major modes
on the <code>viper-emacs-state-mode-list</code> list and delete them from
<code>viper-vi-state-mode-list</code>.
Likewise, you can force Viper's Insert state on a major mode by putting it
in <code>viper-insert-state-mode-list</code>.
<a name="IDX186"></a>
<a name="IDX187"></a>
<a name="IDX188"></a>
</p>
<p>It is also possible to impose Vi on some major modes, even though they may
bind common keys to specialized commands.  This might make sense for modes
that bind only a small number of common keys.  For instance, Viper subverts
the Shell mode by changing the bindings for <kbd>C-m</kbd> and <kbd>C-d</kbd> using
<code>viper-add-local-keys</code> described in section on customization
(see section <a href="#SEC25">Customization</a>).
</p>
<p>In some cases, some <em>minor</em> modes might override certain essential
bindings in Vi command state.  This is not a big priblem because this
can happen only in the beginning, when the minor mode kicks in.  Typing
<code>M-x viper-mode</code> will correct the situation.  Viper knows about
several such minor modes and takes care of them, so the above trick
is usually not necessary.  If you find that some minor mode, e.g.,
<code>nasty-mode.el</code> interferes with Viper, putting the following in
<tt>`.viper'</tt> should fix the problem:
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(viper-harness-minor-mode &quot;nasty-mode&quot;)
</pre></td></tr></table>
<p>The argument to <code>viper-harness-minor-mode</code> is the name of the file for the
offending minor mode with the suffixes <tt>`.el'</tt> and <tt>`.elc'</tt> removed.
</p>
<p>It may not be always obvious which minor mode is at fault.  The only
guidance here is to look into the file that defines the minor mode you are
suspecting, say <code>nasty-mode.el</code>, and see if it has a variable called
<code>nasty-mode-map</code>.  Then check if there is a statement of the form
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(define-key nasty-mode-map key function)
</pre></td></tr></table>
<p>that binds the misbehaving
keys.  If so, use the above line to harness <code>nasty-mode</code>.  If your
suspicion is wrong, no harm is done if you harness a minor mode that
doesn't need to be harnessed.
</p>
<a name="IDX189"></a>
<a name="IDX190"></a>
<a name="IDX191"></a>
<a name="IDX192"></a>
<a name="IDX193"></a>
<a name="IDX194"></a>
<a name="IDX195"></a>
<a name="IDX196"></a>

<hr size="6">
<a name="Viper-Specials"></a>
<a name="SEC29"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC28" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC30" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC25" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC25" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="viper_5.html#SEC31" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="viper.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="viper_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="viper_7.html#SEC51" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="viper_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.3 Viper Specials </h2>

<p>Viper extends Vi with a number of useful features.  This includes various
search functions, histories of search strings, Ex commands, insertions, and
Vi's destructive commands.  In addition, Viper supports file name completion
and history, completion of Ex commands and variables, and many other
features.  Some of these features are explained in detail elsewhere in this
document.  Other features are explained here.
</p>
<dl compact="compact">
<dt> <code>(viper-buffer-search-enable)</code></dt>
<dt> <code>viper-buffer-search-char nil</code></dt>
<dd><p>Enable buffer search.  Explicit call to <code>viper-buffer-search-enable</code>
sets <code>viper-buffer-search-char</code> to <kbd>g</kbd>.  Alternatively, the user can
set <code>viper-buffer-search-char</code> in <tt>`.viper'</tt> to a key sequence
to be used for buffer search.  There is no need to call
<code>viper-buffer-search-enable</code> in that case.
<a name="IDX197"></a>
<a name="IDX198"></a>
</p></dd>
<dt> <code>viper-toggle-search-style</code></dt>
<dd><p>This function, bound to <kbd>C-c /</kbd>, lets one toggle case-sensitive and
case-insensitive search, and also switch between plain vanilla search and
search via regular expressions.  Without the prefix argument, the user is
asked which mode to toggle.  With prefix argument 1, this toggles
case-sensitivity.  With prefix argument 2, regular expression/vanilla search
will be toggled.
</p>
<p>However, we found that the most convenient way to toggle
these options is to bind a Vi macro to
bind <kbd>//</kbd> to toggles case sensitivity and to <kbd>///</kbd> to toggles
vanilla search.  Thus, quickly hitting <kbd>/</kbd> twice will switch Viper from
case sensitive search to case-insensitive.  Repeating this once again will
restore the original state.  Likewise, quickly hitting <kbd>/</kbd> three times
will switch you from vanilla-style search to search via regular expressions.
If you hit something other than <kbd>/</kbd> after the first <kbd>/</kbd> or if the
second <kbd>/</kbd> doesn't follow quickly enough, then Viper will issue the
usual prompt <kbd>/</kbd> and will wait for input, as usual in Vi.
If you don't like this behavior, you can &quot;unrecord&quot; these macros in your
<tt>`~/.viper'</tt> file.  For instance, if you don't like the above feature, put
this in <tt>`~/.viper'</tt>:
</p><table><tr><td>&nbsp;</td><td><pre class="example">(viper-set-searchstyle-toggling-macros 'undefine)
</pre></td></tr></table><a name="IDX199"></a>

</dd>
<dt> <code>Vi-isms in Emacs state</code></dt>
<dd><p>Some people find it useful to use the Vi-style search key, `/', to invoke
search in modes which Viper leaves in emacs-state.  These modes are:
<code>dired-mode</code>, <code>mh-folder-mode</code>, <code>gnus-group-mode</code>,
<code>gnus-summary-mode</code>, <code>Info-mode</code>, and <code>Buffer-menu-mode</code>
(more may be added in the future).  So, in the above modes, Viper binds `/'
so that it will behave Vi-style.  Furthermore, in those major modes, Viper
binds `:' to invoke ex-style commands, like in vi-state.  And, as described
above, `//' and `///' get bound to Vi-style macros that toggle
case-insensitivity and regexp-search.
</p>
<p>If you don't like these features--which I don't really understand--you
can unbind `/' and `:' in <code>viper-dired-modifier-map</code> (for Dired) or in
<code>viper-slash-and-colon-map</code>, for other modes.
<a name="IDX200"></a>
<a name="IDX201"></a>
</p>
<p>To unbind the macros `//' and `///' for a major mode where you feel they
are undesirable, execute <code>viper-set-emacs-state-searchstyle-macros</code> with a
non-nil argument.  This can be done either interactively, by supplying a
prefix argument, or by placing
</p><table><tr><td>&nbsp;</td><td><pre class="example">(viper-set-emacs-state-searchstyle-macros 'undefine)
</pre></td></tr></table><a name="IDX202"></a>
<p>in the hook to the major mode (e.g., <code>dired-mode-hook</code>).
See section <a href="#SEC30">Vi Macros</a>, for more information on Vi macros.
</p>
</dd>
<dt> <code>viper-heading-start</code></dt>
<dt> <code>viper-heading-end</code></dt>
<dd><a name="IDX203"></a>
<a name="IDX204"></a>
<a name="IDX205"></a>
<a name="IDX206"></a>
<p>Regular Expressions for <kbd>[[</kbd> and <kbd>]]</kbd>.  Note that Emacs defines
Regexps for paragraphs and sentences.  See <a href="../emacs/Paragraphs.html#Paragraphs">(emacs)Paragraphs</a> section `Paragraphs and Sentences' in <cite>The GNU Emacs Manual</cite>, for details.
</p></dd>
<dt> <code>M-x viper-set-expert-level</code></dt>
<dd><a name="IDX207"></a>
<p>Change your user level interactively.
</p></dd>
<dt> <code>viper-smart-suffix-list  '(&quot;&quot; &quot;tex&quot; &quot;c&quot; &quot;cc&quot; &quot;el&quot; &quot;p&quot;)</code></dt>
<dd><a name="IDX208"></a>
<p>Viper supports Emacs-style file completion when it prompts the user for a
file name.  However, in many cases, the same directory may contain files
with identical prefix but different suffixes, e.g., prog.c, prog.o,
paper.tex, paper.dvi.  In such cases, completion will stop at the `.'.
If the above variable is a list of strings representing suffixes, Viper will
try these suffixes
in the order listed and will check if the corresponding file exists.
</p>
<p>For instance, if completion stopped at `paper.' and the user typed
<kbd>RET</kbd>,
then Viper will check if the files `paper.', `paper.tex', `paper.c', etc., exist.
It will take the first such file.  If no file exists, Viper will give a chance
to complete the file name by typing the appropriate suffix.  If `paper.' was
the intended file name, hitting return will accept it.
</p>
<p>To turn this feature off, set the above variable to <code>nil</code>.
</p>
</dd>
<dt> <code>viper-insertion-ring-size  14</code></dt>
<dd><a name="IDX209"></a>
<a name="IDX210"></a>
<p>Viper remembers what was previously inserted in Insert and Replace states.
Several such recent insertions are kept in a special ring of strings of size
<code>viper-insertion-ring-size</code>.
If you enter Insert or Replace state you can reinsert strings from this
ring by typing <kbd>C-c M-p</kbd> or <kbd>C-c M-n</kbd>.  The former will search the
ring in
the direction of older insertions, and the latter will search in
the direction of newer insertions.  Hitting <kbd>C-c M-p</kbd> or <kbd>C-c M-n</kbd>
in succession
will undo the previous insertion from the ring and insert the next item on
the ring.  If a larger ring size is needed, change the value of the above
variable in the <tt>`~/.viper'</tt> file.
</p>
<p>Since typing these sequences of keys may be tedious, it is suggested that the
user should bind a function key, such as <kbd>f31</kbd>, as follows:
</p><table><tr><td>&nbsp;</td><td><pre class="example">(define-key viper-insert-global-user-map [f31]
            'viper-insert-prev-from-insertion-ring)
</pre></td></tr></table><p>This binds <kbd>f31</kbd> (which is usually <kbd>R11</kbd> on a Sun workstation)
to the function that inserts the previous string in the insertion history.
To rotate the history in the opposite
direction, you can either bind an unused key to
<code>viper-insert-next-from-insertion-ring</code> or hit any digit (1 to 9) then
<kbd>f31</kbd>.
</p>
<p>One should not bind the above functions to <kbd>M-p</kbd> or <kbd>M-n</kbd>, since
this will interfere with the Minibuffer histories and, possibly, other
major modes.
</p>
</dd>
<dt> <code>viper-command-ring-size  14</code></dt>
<dd><a name="IDX211"></a>
<a name="IDX212"></a>
<a name="IDX213"></a>
<p>Viper keeps track of the recent history of destructive
commands, such as <kbd>dw</kbd>, <kbd>i</kbd>, etc.
In Vi state,
the most recent command can be re-executed by hitting `<kbd>.</kbd>', as in Vi.
However, repeated typing <kbd>C-c M-p</kbd> will cause Viper to show the
previous destructive commands in the minibuffer.  Subsequent hitting `<kbd>.</kbd>'
will execute the command that was displayed last.
The key <kbd>C-c M-n</kbd> will cycle through the command history in the
opposite direction.
Since typing <kbd>C-c M-p</kbd> may be tedious, it is more convenient to bind an
appropriate function to an unused function key on the keyboard and use that
key.  For instance, the following
</p><table><tr><td>&nbsp;</td><td><pre class="example">(define-key viper-vi-global-user-map [f31]
            'viper-prev-destructive-command)
</pre></td></tr></table><p>binds the key <kbd>f31</kbd> (which is usually <kbd>R11</kbd> on a Sun workstation)
to the function that searches the command history in the direction of older
commands.  To search in the opposite
direction, you can either bind an unused key to
<code>viper-next-destructive-command</code> or hit any digit (1 to 9) then <kbd>f31</kbd>.
</p>
<p>One should not bind the above functions to <kbd>M-p</kbd> or <kbd>M-n</kbd>, since
this will interfere with the Minibuffer histories and, possibly, other
major modes.
</p>
</dd>
<dt> <code>viper-minibuffer-vi-face  'viper-minibuffer-vi-face</code></dt>
<dt> <code>viper-minibuffer-insert-face  'viper-minibuffer-insert-face</code></dt>
<dt> <code>viper-minibuffer-emacs-face  'viper-minibuffer-emacs-face</code></dt>
<dd><p>These faces control the appearance of the minibuffer text in the
corresponding Viper states.  You can change the appearance of these faces
through Emacs' customization widget, which is accessible through the
menubar.
</p>
<p>Viper is located in this widget under the <em>Emulations</em> customization
subgroup of the <em>Editing</em> group.  All Viper faces are grouped together
in Viper's <em>Highlighting</em> customization subgroup.
</p>
<p>Note that only the text you type in is affected by the above faces.
Prompts and Minibuffer messages are not affected.
</p>
<p>Purists who do not like adornments in the minibuffer can always zap them by
putting
</p><table><tr><td>&nbsp;</td><td><pre class="example">(copy-face 'default 'viper-minibuffer-vi-face)
(copy-face 'default 'viper-minibuffer-insert-face)
(copy-face 'default 'viper-minibuffer-emacs-face)
</pre></td></tr></table><p>in the <tt>`~/.viper'</tt> file or through the customization widget, as
described above.  However, in that case, the user will not have any
indication of the current Viper state in the minibuffer.  (This is important
if the user accidentally switches to another Viper state by typing <kbd>ESC</kbd> or
<kbd>C-z</kbd>).
</p></dd>
<dt> <code>M-x viper-go-away</code></dt>
<dd><a name="IDX214"></a>
<p>Make Viper disappear from the face of your running Emacs instance.  If your
fingers start aching again, <kbd>M-x viper-mode</kbd> might save your day.
</p></dd>
<dt> <code>M-x toggle-viper-mode</code></dt>
<dd><a name="IDX215"></a>
<p>Toggle Viperization of Emacs on and off.
</p></dd>
</dl>

<a name="IDX216"></a>

<p>Viper provides some support for multi-file documents and programs.
If a document consists of several files we can designate one of them as a
master and put the following at the end of that file:
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">;;; Local Variables:
;;; eval: (viper-setup-master-buffer &quot;file1&quot; &quot;file2&quot; &quot;file3&quot; &quot;file4&quot;)
;;; End:
</pre></td></tr></table>
<p>where <code>file1</code> to <code>file4</code> are names of files related to the master
file.  Next time, when the master file is visited, the command
<code>viper-setup-master-buffer</code> will be evaluated and the above files will
be associated with the master file.  Then, the new Ex command
<kbd>:RelatedFile</kbd> (abbr. <kbd>:R</kbd>) will display files 1 to 4 one after
another, so you can edit them.  If a file is not in any Emacs buffer, it
will be visited.  The command <kbd>PreviousRelatedFile</kbd> (abbr., <kbd>:P</kbd>)
goes through the file list in the opposite direction.
<a name="IDX217"></a>
<a name="IDX218"></a>
</p>
<p>These commands are akin to <kbd>:n</kbd> and <kbd>:N</kbd>, but they allow the user to
focus on relevant files only.
</p>
<p>Note that only the master file needs to have the aforementioned block of
commands.  Also, &quot;;;;&quot; above can be replaced by some other
markers.  Semicolon is good for Lisp programs, since it is considered a
comment designator there.  For LaTeX, this could be &quot;%%%&quot;, and for C the
above block should be commented out.
</p>
<p>Even though these commands are sometimes useful, they are no substitute for
the powerful <em>tag table</em> facility of Emacs.  Viper's <kbd>:tag</kbd> command
in a primitive interface to Emacs tags.  See <a href="../emacs/Tags.html#Tags">Tags: (emacs)Tags</a> section `Tags' in <cite>The Gnu Emacs Manual</cite>, for more information on tags.
</p>
<p>The following two commands are normally bound to a mouse click and are part
of Viper.  They work only if Emacs runs as an application under X
Windows (or under some other window system for which a port of GNU Emacs 20
is available).  Clicking the mouse when Emacs is invoked in an Xterm window
(using <code>emacs -nw</code>) will do no good.
</p>
<dl compact="compact">
<dd><a name="IDX219"></a>
<a name="IDX220"></a>
</dd>
<dt> <code>viper-mouse-search-key  (meta shift 1)</code></dt>
<dd><a name="IDX221"></a>
<p>This variable controls the <em>mouse-search</em> feature of Viper.  The
default value
states that holding Meta and Shift keys while clicking mouse button 1
should initiate search for a region under the mouse pointer (defined
below).  This command can take a prefix argument, which indicates the
occurrence of the pattern to search for.
</p>
<p>Note: while loading initially, Viper binds this mouse action only if it is
not already bound to something else.  If you want to use the mouse-search
feature, and the <kbd>Meta-Shift-Mouse-1</kbd> mouse action is already bound to
something else, you can rebind the mouse-search feature by setting
<code>viper-mouse-search-key</code> to something else in your <code>~/.viper</code>
file:
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(setq viper-mouse-search-key '(meta 1))
</pre></td></tr></table><p>This would bind mouse search to the action invoked by pressing the
Meta key and clicking mouse button 1.  The allowed values of
<code>viper-mouse-search-key</code> are lists that contain a mouse-button number
(1,2, or 3) and any combination of the words `control', `meta', and
`shift'.
</p>
<p>If the requested mouse action (e.g., (meta 1)) is already taken for other
purposes then you have to confirm your intention by placing the following
command in <code>~/.viper</code> after setting <code>viper-mouse-search-key</code>:
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(viper-bind-mouse-search-key 'force)
</pre></td></tr></table>
<p>You can also change this setting interactively, through the customization
widget of Emacs (type <kbd>:customize</kbd>).
</p>
<p>The region that is chosen as a pattern to search for is determined as
follows.  If search is invoked via a single click, Viper chooses the region
that lies between the beginning of the &quot;word&quot; under the pointer (&quot;word&quot;
is understood in Vi sense) and the end of that word.  The only difference
with Vi's words is that in Lisp major modes `-' is considered an
alphanumeric symbol.  This is done for the convenience of working with Lisp
symbols, which often have an `-' in them.  Also, if you click on a
non-alphanumeric character that is not a word separator (in Vi sense) then
this character will also be considered alphanumeric, provided that it is
adjacent (from either side) to an alphanumeric character.  This useful
feature gives added control over the patterns selected by the mouse click.
</p>
<p>On a double-click, the region is determined by the beginning of the current
Vi's &quot;Word&quot; (i.e., the largest non-separator chunk of text) and the End
of that &quot;Word&quot; (as determined by the <kbd>E</kbd> command).
</p>
<p>On a triple-click, the region consists of the entire line where the click
occurred with all leading and trailing spaces and tabs removed.
</p>
<a name="IDX222"></a>
</dd>
<dt> <code>viper-mouse-insert-key (meta shift 2)</code></dt>
<dd><a name="IDX223"></a>
<p>This variable controls the <em>mouse-insert</em> feature of Viper.
The above default value states that
holding Meta and Shift keys while clicking mouse button 2
should insert the region surrounding the
mouse pointer.  The rules defining this region are the same as for
mouse-search.  This command takes an optional prefix argument, which
indicates how many such regions to snarf from the buffer and insert.  (In
case of a triple-click, the prefix argument is ignored.)
</p>
<p>Note: while loading initially, Viper binds this mouse action only if it not
already bound to something else.  If you want to use this feature and the
default mouse action is already bound, you can rebind mouse-insert by
placing this command in <code>~/.viper</code>:
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(setq viper-mouse-insert-key '(meta 2))
</pre></td></tr></table><p>If you want to bind mouse-insert to an action even if this action is
already taked for other purposes in Emacs, then you should add this command
to <code>~/.viper</code>, after setting <code>viper-mouse-insert-key</code>:
</p><table><tr><td>&nbsp;</td><td><pre class="lisp">(viper-bind-mouse-insert-key 'force)
</pre></td></tr></table>
<p>This value can also be changed via the Emacs customization widget at the
menubar.
</p>
</dd>
<dt> <code>viper-multiclick-timeout</code></dt>
<dd><p>This variable controls the rate at which double-clicking must occur for the
purpose of mouse search and mouse insert.  By default, this is set to
<code>double-click-time</code> in Emacs and to
<code>mouse-track-multi-click-time</code> milliseconds in XEmacs.
</p></dd>
</dl>
       
<a name="IDX224"></a>
<a name="IDX225"></a>
<a name="IDX226"></a>
<a name="IDX227"></a>
<a name="IDX228"></a>
<a name="IDX229"></a>
<a name="IDX230"></a>

<p>Note: The above functions search and insert in the selected window of
the latest active frame.  This means that you can click in another window or
another frame and have search or insertion done in the frame and window you
just left.  This lets one use these functions in a multi-frame
configuration.  However, this may require some getting used to.  For
instance, if you are typing in a frame, A, and then move the mouse to frame
B and click to invoke mouse search, search (or insertion) will be performed
in frame A.  To perform search/insertion in frame B, you will first have to
shift focus there, which doesn't happen until you type a character or
perform some other action in frame B--mouse search doesn't shift focus.
</p>
<p>If you decide that you don't like the above feature and always want
search/insertion be performed in the frame where the click occurs, don't
bind (and unbind, if necessary) <code>viper-mouse-catch-frame-switch</code> from
the mouse event it is bound to.
</p>
<p>Mouse search is integrated with Vi-style search, so you can
repeat it with <kbd>n</kbd> and <kbd>N</kbd>.  It should be also noted that, while
case-sensitivity of search in Viper is controlled by the variable
<code>viper-case-fold-search</code>, the case of mouse search is
controlled by the Emacs variable <code>case-fold-search</code>, which may be set
differently from <code>viper-case-fold-search</code>.  Therefore, case-sensitivity
of mouse search may be different from that of the usual Vi-style search.
</p>
<p>Finally, if the way Viper determines the word to be searched for or to be
inserted is not what you want, there is a variable,
<code>viper-surrounding-word-function</code>, which can be changed to indicate
another function for snarfing words out of the buffer.  The catch is that
you will then have to write such a function and make it known to your
Emacs.  The function <code>viper-surrounding-word</code> in <tt>`viper.el'</tt> can be
used as a guiding example.
</p>
<hr size="6">
<a name="Vi-Macros"></a>
<a name="SEC30"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC29" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="viper_5.html#SEC31" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC25" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC25" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="viper_5.html#SEC31" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="viper.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="viper_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="viper_7.html#SEC51" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="viper_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 3.4 Vi Macros </h2>


<p>Viper supports much enhanced Vi-style macros and also facilitates the use
of Emacs-style macros.  To define a temporary macro, it is generally more
convenient to use Emacs keyboard macro facility.  Emacs keyboard macros are
usually defined anonymously, and the latest macro can be executed by typing
<kbd>C-x e</kbd> (or <kbd>*</kbd>, if Viper is in Vi state).  If you need to use several
temporary macros, Viper lets you save them to a
register (a lowercase letter); such macros can then be executed by typing
<kbd>@a</kbd> in Vi state (if a macro was previously saved in register
<kbd>a</kbd>).
See section <a href="viper_3.html#SEC18">Macros and Registers</a>, for details.
</p>
<p>If, however, you need to use a macro regularly, it must be given a
permanent name and saved.  Emacs manual explains how to do this, but
invocation of named Emacs macros is quite different from Vi's.  First,
invocation of permanent Emacs macros takes time because it requires typing
too many keys (to  a Vi user's taste, anyway).
Second, binding such macros to function keys, for
fast access, hogs valuable real estate on the keyboard.
</p>
<p>Vi-style macros are better in that respect, since Vi lets the user overload
the meaning of key sequences: keys typed in fast succession are treated
specially, if this key sequence is bound to a macro.
</p>
<p>Viper provides Vi-style keyboard macros through the usual Ex commands,
<kbd>:map</kbd> and 
<kbd>:map!</kbd>.  These macros are much more powerful in Viper than
they are in the original Vi and in other emulators.  This is because Viper
implements an enhanced vi-style
interface to the powerful Emacs keyboard macro facility.
</p>
<p>First, any Emacs
command can be executed while defining a macro, not just the Vi
commands.  In particular, the user can invoke Emacs commands via <kbd>M-x
command-name</kbd> or by pressing various function keys on the keyboard.  One
can even use the mouse, although this is usually not useful and is not
recommended (and macros defined with the use of the mouse cannot be saved in
command history and in the startup file, for future use).
</p>
<p>Macros defined by mixing Vi and Emacs commands are represented as
vectors.  So, don't be confused when you see one (usually through the
history of Ex commands).  For instance, if <kbd>gg</kbd> is defined by typing
<kbd>l</kbd>, the up-arrow key and <kbd>M-x next-line</kbd>, its definition will look
as follows in Emacs (in XEmacs, it looks slightly different, see below):
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">[l up (meta x) n e x t - l i n e return]
</pre></td></tr></table>
<p>Second, Viper macros are defined in a WYSIWYG style.  This means that
commands are executed as you type them, so you can see precisely what is
being defined.  Third, macros can be bound to arbitrary sequences of keys,
not just to printable keys.  For instance, one can define a macro that will
be invoked by hitting <kbd>f3</kbd> then <kbd>f2</kbd> function keys.  (The keys
<kbd>delete</kbd> and <kbd>backspace</kbd> are excluded; also, a macro invocation
sequence can't start with <kbd>ESC</kbd>.  Some other keys, such as <kbd>f1</kbd> and
<kbd>help</kbd>, can't be bound to macros under Emacs, since they
are bound in <code>key-translation-map</code>, which overrides any other binding
the user gives to keys.  In general, keys that have a binding in
<code>key-translation-map</code> can't be bound to a macro.)
</p>
<p>Fourth, in Viper, one can define macros that are specific to a given
buffer, a given major mode, or macros that are defined for all buffers.  In
fact, the same macro name can have several different definitions: one
global, several definitions for various major modes, and
definitions for various specific buffers.  Buffer-specific definitions
override mode-specific definitions, which, in turn, override global
definitions.
</p>
<p>As if all that is not enough, Viper (through its interface to Emacs
macros) lets the user define keyboard macros that ask for confirmation or
even prompt the user for input and then continue.  To do this, one should
type <kbd>C-x q</kbd> (for confirmation) or <kbd>C-u C-x q</kbd> (for prompt).
For details, see <a href="../emacs/Kbd-Macro-Query.html#Kbd-Macro-Query">(emacs)Kbd Macro Query</a> section `Customization' in <cite>The GNU Emacs Manual</cite> 
</p>
<p>When the user finishes defining a macro (which is done by typing <kbd>C-x)</kbd> --
a departure from Vi), you will be asked whether you want this
macro to be global, mode-specific, or buffer-specific.  You will also be
given a chance to save the macro in your <tt>`~/.viper'</tt> file.
This is the easiest way to save a macro and make
it permanently available.  If you work your startup files with bare hands,
here is how Viper saves the above macro so that it will be
available in Viper's Insert state (and Replace state) in buffer <code>my-buf</code>
only:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(viper-record-kbd-macro &quot;gg&quot; 'insert-state
       [l up (meta x) n e x t - l i n e return]
       &quot;my-buf&quot;)
</pre></td></tr></table>

<p>To do the same for Vi state and all buffers with the major mode
<code>cc-mode</code>, use:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(viper-record-kbd-macro &quot;gg&quot; 'vi-state
       [l up (meta x) n e x t - l i n e return]
       'cc-mode)
</pre></td></tr></table>

<p>Both macro names and macro definitions are vectors of symbols that denote
keys on the keyboard.  Some keys, like <kbd>\</kbd>, <kbd> </kbd>, or digit-keys must
be escaped with a backslash.  Modified keys are represented as lists.  For
instance, holding Meta and Control and pressing <kbd>f4</kbd> is represented as
<kbd>(control meta f4)</kbd>.
If all members of a vectors are printable characters (or sequences, such as
<kbd>\e</kbd>, <kbd>\t</kbd>, for <kbd>ESC</kbd> and <kbd>TAB</kbd>), then they can also be represented as
strings:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(viper-record-kbd-macro &quot;aa&quot; 'vi-state  &quot;aaa\e&quot;  &quot;my-buffer&quot;)
</pre></td></tr></table>

<p>Thus, typing <kbd>aa</kbd> fast in Vi state will switch Viper to Insert state
(due to the first <kbd>a</kbd>), insert <kbd>aa</kbd>, and then it will switch back to Vi
state.  All this will take effect only in the buffer named <code>my-buffer</code>.
</p>
<p>Note that the last argument to <code>viper-record-kbd-macro</code> must be either a
string (a buffer name), a symbol representing a major mode, or <code>t</code>;
the latter says that the macro is to be defined for all buffers
(which is how macros are defined in original Vi).
</p>
<p>For convenience, Viper also lets you define Vi-style macros in its Emacs
state.  There is no Ex command, like <kbd>:map</kbd> and <kbd>:map!</kbd> for doing
this, but the user can include such a macro in the <tt>`~/.viper'</tt> file.  The
only thing is that the <code>viper-record-kbd-macro</code> command should specify
<code>emacs-state</code> instead of <code>vi-state</code> or <code>insert-state</code>.
</p>
<p>The user can get rid of a macro either by using the Ex commands <kbd>:unmap</kbd>
and <kbd>:unmap!</kbd> or by issuing a call to <code>viper-unrecord-kbd-macro</code>.
The latter is more powerful, since it can delete macros even in
<code>emacs-state</code>.  However, <code>viper-unrecord-kbd-macro</code> is usually
needed only when the user needs to get rid of the macros that are already
predefined in Viper.
The syntax is:
<a name="IDX231"></a>
</p><table><tr><td>&nbsp;</td><td><pre class="example">(viper-unrecord-kbd-macro macro state)
</pre></td></tr></table>
<p>The second argument must be <code>vi-state</code>, <code>insert-state</code>, or
<code>emacs-state</code>.  The first argument is a name of a macro.  To avoid
mistakes in specifying names of existing macros, type <kbd>M-x
viper-describe-kbd-macros</kbd> and use a name from the list displayed by this
command.
</p>
<p>If an error occurs during macro definition, Emacs
aborts the process, and it must be repeated.  This is analogous to Vi,
except that in Vi the user doesn't know there is an error until the macro is
actually run.  All that means that in order for a definition to be
successful, the user must do some simple planning of the process in
advance, to avoid errors.  For instance, if you want to map <kbd>gg</kbd> to
<kbd>llll</kbd> in Vi state, you must make sure that there is enough room on the
current line.  Since <kbd>l</kbd> moves the cursor forward, it may signal an
error on reaching the end of line, which will abort the definition.
</p>
<p>These precautions are necessary only when defining macros; they will help
avoid the need to redo the job.  When macros are actually run, an error
during the execution will simply terminate the current execution
(but the macro will remain mapped).
</p>
<p>A macro name can be a string of characters or a vector of keys.
The latter makes it possible to define macros bound to, say, double-hits
on a function key, such as <kbd>up</kbd> or <kbd>f13</kbd>.
This is very useful if you run out of function keys on your keyboard; it
makes Viper macro facility a <em>keyboard doubler</em>, so to speak.
</p>
<p>Elsewhere (See section <a href="#SEC27">Key Bindings</a>, for details), we review
the standard Emacs mechanism for binding function keys to commands.
For instance,
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(global-set-key [f13] 'repeat-complex-command)
</pre></td></tr></table>

<p>binds the key f13 to the Emacs function that repeats the last minibuffer
command.  Under Viper, however, you may still use this key for additional
purposes, if you bind, say, a double-hitting action for that key to some
other function.  Emacs doesn't allow the user to do that, but Viper does
this through its keyboard macro facility.  To do this, type <kbd>:map </kbd>
first.  When you are asked to enter a macro name, hit f13 twice, followed by
<kbd>RET</kbd> or <kbd>SPC</kbd>.
</p>
<p>Emacs will now start the mapping process by actually executing
Vi and Emacs commands, so that you could see what will happen each time the
macro is executed.  Suppose now we wanted to bind the key sequence
<kbd>f13 f13</kbd> to the command <code>eval-last-sexp</code>.  To accomplish this, we
can type <kbd>M-x eval-last-sexp</kbd> followed by <kbd>C-x )</kbd>.
If you answer positively to Viper's offer to save this macro in <tt>`~/.viper'</tt>
for future uses, the following will be inserted in that file:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(viper-record-kbd-macro [f16 f16] 'vi-state
         [(meta x) e v a l - l a s t - s e x p]
         'lisp-interaction-mode)
</pre></td></tr></table>
<p>To illustrate the above point, Viper provides two canned macros, which, by
default, are bound to <kbd>[f12 \1]</kbd> and <kbd>[f12 \2]</kbd> (invoked by typing
<kbd>f12</kbd> then <kbd>1</kbd> and <kbd>2</kbd>, respectively).  These macros are useful
shortcuts to Viper's command ring history.  The first macro will execute the
second-last destructive command (the last one is executed by <kbd>.</kbd>, as
usual).  The second macro executes the third-last command.
</p>
<p>If you need to go deeper into the command history, you will have to use
other commands, as described earlier in this section; or you can bind,
say, <kbd>f12 \3</kbd> like this:
</p>
<table><tr><td>&nbsp;</td><td><pre class="example">(viper-record-kbd-macro [f12 \3] 'vi-state
                      [(meta x) r e p e a t - f r o m - h i s t o r y]
                      t)
</pre></td></tr></table>

<p>Note that even though the macro uses the function key <kbd>f12</kbd>, the key is
actually free and can still be bound to some Emacs function via
<code>define-key</code> or <code>global-set-key</code>.
</p>

<p>Viper allows the user to define macro names that are prefixes of other macros.
For instance, one can define <kbd>[[</kbd> and <kbd>[[[[</kbd> to be macros.
If you type the exact sequence of such keys and then pause, Viper will
execute the right macro.  However, if you don't pause and, say, type
<kbd>[[[[text</kbd> then the conflict is resolved as follows.  If only one of the
key sequences, <kbd>[[</kbd> or <kbd>[[[[</kbd> has a definition applicable to the
current buffer, then, in fact, there is no conflict and the right macro
will be chosen.  If both have applicable definitions, then the first one
found will be executed.  Usually this is the macro with a shorter name.  So,
in our case, <kbd>[[[[text</kbd> will cause the macro <kbd>[[</kbd> to be executed
twice and then the remaining keys, <kbd>t e x t</kbd>, will be processed.
</p>
<p>When defining macros using <kbd>:map</kbd> or <kbd>:map!</kbd>, the user enters
the actually keys to be used to invoke the macro.  For instance, you
should hit the actual key <kbd>f6</kbd> if it is to be part of a macro
name; you do <em>not</em> write <kbd>f 6</kbd>.  When entering keys, Viper
displays them as strings or vectors (e.g., <code>&quot;abc&quot;</code> or <code>[f6
f7 a]</code>).  The same holds for unmapping.  Hitting <kbd>TAB</kbd> while
typing a macro name in the <kbd>:unmap</kbd> or <kbd>:unmap!</kbd> command will
cause name completion.  Completions are displayed as strings or
vectors.  However, as before, you don't actually type <samp>`&quot;'</samp>,
<samp>`['</samp>, or <samp>`]'</samp> that appear in the completions.  These are
meta-symbols that indicate whether the corresponding macro name is a
vector or a string.
</p>
<p>One last difference from Vi: Vi-style keyboard macros cannot be defined in
terms of other Vi-style keyboard macros (but named Emacs macros are OK).
More precisely, while defining or executing a macro, the special meaning
of key sequences (as Vi macros) is ignored.
This is because it is all too easy to create an infinite loop in this way.
Since Viper macros are much more powerful than Vi's it is impossible to
detect such loops.  In practice, this is not really a limitation but,
rather, a feature.
</p>
<p>We should also note that Vi macros are disabled in the Minibuffer, which
helps keep some potential troubles away.
</p>
<p>The rate at which the user must type keys in order for them to be
recognized as a timeout macro is controlled by the variable
<code>viper-fast-keyseq-timeout</code>, which defaults to 200 milliseconds.
</p>
<p>For the most part, Viper macros defined in <tt>`~/.viper'</tt> can be shared
between Emacs, XEmacs, and X and TTY modes.  However, macros defined via
function keys may need separate definitions when XEmacs and Emacs have
different names for the same keyboard key.  For instance, the `Page Up' key
may be known in Emacs as <kbd>prior</kbd> and in XEmacs as <kbd>pgup</kbd>.
The problem with TTY may be that the function keys there generate sequences
of events instead of a single event (as under a window system).
Emacs maps some of these sequences back to the logical keys
(e.g., the sequences generated by the arrow keys are mapped to <kbd>up</kbd>,
<kbd>left</kbd>, etc.).  However, not all function keys are mapped in this way.
Macros that are bound to key sequences that contain such unmapped function
keys have to be redefined for TTY's (and possibly for every type of TTY you
may be using).  To do this, start Emacs on an appropriate TTY device and
define the macro using <kbd>:map</kbd>, as usual.
</p>
<a name="IDX232"></a>
<p>Finally, Viper provides a function that conveniently displays all macros
currently defined.  To see all macros along with their definitions, type
<kbd>M-x viper-describe-kbd-macros</kbd>.
</p>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC25" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="viper_5.html#SEC31" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="viper.html#Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="viper_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="viper_7.html#SEC51" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="viper_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>a tester</em> on <em>a sunny day</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html</em></a>.
 </font>
 <br>

</p>
</body>
</html>
