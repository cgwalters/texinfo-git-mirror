
########## WORK IN PROGRESS ##################

#+##############################################################################
#
# info.init: convert to info
#
#    Copyright (C) 2008  Patrice Dumas <dumas@centre-cired.fr>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
#    02110-1301  USA
#
#-##############################################################################

use Data::Dumper;

use strict;

$USE_NODES = 1;
$USE_SECTIONS = 0;
@EXPAND = ('info');
$EXTENSION = 'info';
$SHOW_MENU = 1;
$USE_SETFILENAME = 1;
$IGNORE_BEFORE_SETFILENAME = 1;
$NODE_NAME_IN_MENU = 1;
$SPLIT_INDEX = 0;
$SEPARATED_FOOTNOTES = 0;
$INLINE_CONTENTS = 1;
$SIMPLE_MENU = 1;
$MENU_SYMBOL = '*';
$USE_MENU_DIRECTIONS = 0;
$USE_ISO = 0;
@IMAGE_EXTENSIONS = ('png', 'jpg', 'txt');

$no_paragraph_commands{'anchor'} = 1;

%simple_map = %ascii_simple_map;
%simple_map_pre = %simple_map;
%simple_map_texi = %simple_map;

%things_map = %ascii_things_map;
%pre_map = %things_map;

$misc_command{'exdent'}->{'keep'} = 1;
$misc_command{'noindent'}->{'keep'} = 1;
$misc_command{'indent'}->{'keep'} = 1;

# sc and var upcase.
my @simple_quoted_commands = ('cite', 'code', 'command', 'env', 'file', 'kbd',
  'option', 'samp');
# slanted? 
my @asis_commands = ('asis', 'b', 'ctrl', 'dmn', 'i', 'math', 'sc', 't', 'r', 
  'slanted', 'var', 'titlefont', 'verb', 'clickstyle');
my @chevron_commands = ('key', 'indicateurl');

my %info_default_accent_commands = ();

foreach my $accent_command ('tieaccent', 'dotless', keys(%unicode_accents), keys(%accent_map))
{
     $info_default_accent_commands{$accent_command} = 1;
     $style_map{$accent_command} = { 'function' => \&info_default_accent };
}

foreach my $command (keys(%style_map))
{
    delete $style_map{$command}->{'attribute'} if (exists($style_map{$command}->{'attribute'}));
    delete $style_map{$command}->{'quote'} if (exists($style_map{$command}->{'quote'}));
    if (grep {$_ eq $command} @simple_quoted_commands)
    {
        delete $style_map{$command}->{'function'} if (exists($style_map{$command}->{'function'}));
        $style_map{$command}->{'begin'} = '`';
        $style_map{$command}->{'end'} = "'";
        next;
    }
    elsif (grep {$_ eq $command} @asis_commands)
    {
        delete $style_map{$command}->{'function'} if (exists($style_map{$command}->{'function'}));
        delete $style_map{$command}->{'begin'} if  (exists($style_map{$command}->{'begin'}));
        delete $style_map{$command}->{'end'} if  (exists($style_map{$command}->{'end'}));
    }
    if (grep {$_ eq $command} @chevron_commands)
    {
        delete $style_map{$command}->{'function'} if (exists($style_map{$command}->{'function'}));
        $style_map{$command}->{'begin'} = '<';
        $style_map{$command}->{'end'} = '>';
        next;
    }
}

$style_map{'strong'}->{'begin'} = '*';
$style_map{'strong'}->{'end'} = '*';
$style_map{'dfn'}->{'begin'} = '"';
$style_map{'dfn'}->{'end'} = '"';
$style_map{'emph'}->{'begin'} = '_';
$style_map{'emph'}->{'end'} = '_';

foreach my $command (keys(%style_map))
{
    $style_map_pre{$command} = {};
    $style_map_texi{$command} = {};
    foreach my $key (keys(%{$style_map{$command}}))
    {
        $style_map_pre{$command}->{$key} = $style_map{$command}->{$key};
        $style_map_texi{$command}->{$key} = $style_map{$command}->{$key};
    }
}

my %info_default_leaf_command = ();
foreach my $command ('uref', 'url', 'email')
{
   $info_default_leaf_command{$command} = 1;
   $style_map{$command}->{'orig_args'} = [ @{$style_map{$command}->{'args'}} ];
   $style_map{$command}->{'args'} = [];
   foreach my $arg (@{$style_map{$command}->{'orig_args'}})
   {
      push  @{$style_map{$command}->{'args'}}, 'keep';
   }
}

$style_map{'uref'}->{'function'} = \&info_default_uref;
$style_map{'url'}->{'function'} = \&info_default_uref;

sub info_default_uref($$)
{
    shift;
    my $args = shift;
    my $url = shift @$args;
    my $text = shift @$args;
    my $replacement = shift @$args;
    #$url =~ s/\s*$//;
    #$url =~ s/^\s*//;
    $url = main::normalise_space($url);
    $replacement = '' if (!defined($replacement));
    $replacement = main::normalise_space($replacement);
    return $replacement if ($replacement ne '');
    $text = '' if (!defined($text));
    $text = main::normalise_space($text);
    return "`$url'" if ($text eq '');
    return "$text ($url)";
}

$style_map{'email'}->{'function'} = \&info_default_email;
sub info_default_email($$)
{
    my $command = shift;
    my $args = shift;
    my $mail = shift @$args;
    my $text = shift @$args;
    $mail = main::normalise_space($mail);
    $text = '' if (!defined($text));
    $text = main::normalise_space($text);
    $mail = "<$mail>";
    return $mail unless ($text ne '');
    return "$text $mail";
}

$special_list_commands{'itemize'} = {};
my @info_default_normal_formats = ('table', 'vtable', 'ftable', 'enumerate',
   'itemize');
foreach my $format (@info_default_normal_formats, 'group')
{
    $format_map{$format} = '';
}

my %info_default_indented_commands;
foreach my $command (keys (%{$complex_format_map}), @info_default_normal_formats, 'quotation')
{
    $info_default_indented_commands{$command} = 1;
}


$style = \&info_default_style;
$print_page_head   = \&info_default_print_page_head;
$toc_body = \&info_default_noop;
$about_body = \&info_default_noop;
$print_Footnotes = \&info_default_noop;
$copying_comment   = \&info_default_copying_comment;
$element_heading   = \&info_default_element_heading;
$heading           = \&info_default_heading;
$normal_text       = \&info_default_normal_text;
$paragraph         = \&info_default_paragraph;
$preformatted      = \&info_default_preformatted;
$empty_line               = \&info_default_empty_line;
# maybe should not be called from the main program?
$print_page_foot       = \&info_default_print_page_foot;
$print_Top_footer      = \&info_default_print_Top_footer;
$print_Top             = \&info_default_print_section;
$print_section         = \&info_default_print_section;
$end_section           = \&info_default_end_section;
$one_section           = \&info_default_one_section;
$begin_format_texi     = \&info_default_begin_format_texi;
$begin_style_texi      = \&info_default_begin_style_texi;
$begin_paragraph_texi  = \&info_default_begin_paragraph_texi;
$simple_command        = \&info_default_simple_command;
$thing_command         = \&info_default_thing_command;
$begin_special_region  = \&info_default_begin_special_region;
$end_special_region    = \&info_default_end_special_region;
$anchor_label          = \&info_default_anchor_label;
$element_label         = \&info_default_noop;
$menu_link             = \&info_default_menu_link;
$menu_command          = \&info_default_menu_command;
$complex_format        = \&info_default_complex_format;
$quotation             = \&info_default_quotation;
$unknown               = \&info_default_misc_commands;
$external_ref          = \&info_default_external_ref;
$internal_ref          = \&info_default_internal_ref;
$image                 = \&info_default_image;
$image_files           = \&info_default_image_files;
$index_summary      = \&info_default_index_summary;
$summary_letter     = \&info_default_summary_letter;
$index_entry        = \&info_default_index_entry;
$index_letter       = \&info_default_index_letter;
$print_index        = \&info_default_print_index;
$index_entry_label  = \&info_default_index_entry_label;
$foot_section       = \&info_default_foot_lines;
$foot_line_and_ref  = \&info_default_foot_line_and_ref;
$footnote_texi      = \&info_default_footnote_texi;
$list_item          = \&info_default_list_item;
$format_list_item_texi = \&info_default_format_list_item_texi;
$format             = \&info_default_format;
$tab_item_texi      = \&info_default_tab_item_texi;


sub info_default_accent($$$)
{
    my @args = @_;
    my $command = shift;
    my $args = shift;
    my $text = $args->[0];
    my $style_stack = shift;
    my $state = shift;

    if (scalar(@$style_stack) and $info_default_accent_commands{$style_stack->[-1]})
    {
        return &t2h_default_ascii_accent(@args);
    }
    my $result = &t2h_default_ascii_accent(@args);
    return info_default_store_text($state,$result,'accents_commands');
#    return '' if info_default_store_text($state,$result,'accents_commands');
#    return $result;
}

sub info_default_noop
{
    return '';
}

sub info_default_copying_comment($$$$)
{
    my $copying_lines = shift;
    my $copying_text = shift;
    my $copying_no_texi = shift;
    my $copying_simple_text = shift;
    return '' if ($copying_text eq '');
    return $copying_text;
}

sub info_default_count_lines($)
{
      my $text = shift;
      my @lines = split /^/, $text;
      my $line_passed = scalar(@lines);
      $line_passed-- if ($line_passed);
      my $end_of_line = 0;
      if (chomp($text))
      {
         $line_passed++;
         $end_of_line = 1;
      }
      return ($line_passed, $end_of_line,$lines[-1]);
}

# FIXME initialize
my %info_default_state_map = ();
my $info_default_state;

sub info_default_reset_state($)
{
    my $info_state = shift;
    $info_state->{'top'} = {};
    $info_state->{'current'} = $info_state->{'top'};
}

sub info_default_iterator_next($$$)
{
   my $current_command = shift;
   my $command_index = shift;
   my $command_close = shift;
   
   my $sub_command = $current_command->{'content'}->[$command_index];
   
   if ($sub_command->{'content'} and !$command_close)
   {
      return ($sub_command, 0, 0);
   }
   
   if ($current_command->{'content'}->[$command_index+1])
   {
      return ($current_command, $command_index+1, 0);
   }
   elsif (defined($current_command->{'parent'}))
   {
      return ($current_command->{'parent'}, $current_command->{'index_in_parent'}, 1);
   }
   else
   {
      return (undef, undef, undef);
   }
}

my $info_default_max_column = 72;

# Beware that there is a pending word if the text doesn't end with
# a space
sub info_default_process_text($$$$$$)
{
   my $text = shift;
   my $line_char_counter = shift;
   my $pending_spaces = shift;
   my $pending_word = shift;
   my $indent_length = shift;
   my $in_para = shift;

   my $indent_text = '';
   $indent_text = ' ' x $indent_length if (defined($indent_length));
   
   my $line_passed = 0;
   my $result = '';

print STDERR "process_text(indent `$indent_text', in_para $in_para) line_char_counter $line_char_counter `$text'\n";
   if (!$in_para)
   {
       my $chomped_text = $text;
       if ($line_char_counter == 0 and $chomped_text ne '')
       {
           $text = $indent_text.$text;
       }
       $line_char_counter += length($text);
       if (chomp($chomped_text))
       {
          $line_passed = 1;
          $line_char_counter = 0;
       }
       return ($line_char_counter, $pending_spaces, $pending_word, $line_passed, $text);
   }
   
   while ($text ne '')
   {
      if ($text =~ s/^(\s+)//)
      {
          my $new_spaces = $1;
          if (defined($pending_word))
          {
             if ($line_char_counter == 0)
             {
                 $pending_spaces = $indent_text . $pending_spaces;
             }
             $result .= $pending_spaces . $pending_word;
             $line_char_counter += length($pending_spaces)+length($pending_word);
             $pending_spaces = $new_spaces;
             $pending_word = undef;
         }
         else
         {
             $pending_spaces .= $new_spaces;
         }
         if (length($pending_spaces) +  $line_char_counter > $info_default_max_column)
         {
             $pending_spaces = substr($pending_spaces, $info_default_max_column - $line_char_counter +1);
             $result .= "\n";
             $line_passed++;
             $line_char_counter = 0;
         }
      }
      elsif ($text =~ s/^([^\s]+)//)
      {
         my $word = $1;
         $pending_word = '' if (!defined($pending_word));
         $pending_word .= $word;
         # The $line_char_counter != 0 is here to cope with the case of a 
         # word longer than $line_char_counter followed by more letters:
         # a line would be passed each time some text is appended.
         if ((length($pending_spaces)+length($pending_word) + $line_char_counter > $info_default_max_column) and $line_char_counter != 0)
         {
             $pending_spaces = '';
             $result .= "\n";
             $line_passed++;
             $line_char_counter = 0;
         }
      }
   }
   return ($line_char_counter, $pending_spaces, $pending_word, $line_passed, $result)
}

sub info_default_skip_spaces($$$)
{
    my $current = shift;
    my $index = shift;
    my $close = shift;

    while(1)
    {
       my ($current_next, $index_next, $close_next) = info_default_iterator_next($current, $index, $close);
        return ($current, $index, $close) if (!defined($close_next) or $close_next);
        my $content = $current_next->{'content'}->[$index_next];
        if (defined($content->{'begin'}))
        {
            $content->{'begin'} =~ s/^\s*//;
            return ($current, $index, $close) if ($content->{'begin'} ne '');
        } 
        if (defined($content->{'content'}))
        { # non empty commands stop space skipping, even if they contain 
          # only spaces, like @asis{ }
            return ($current, $index, $close);
        }
        if (defined($content->{'text'}))
        {
            $content->{'text'} =~ s/^\s*//;
            return ($current, $index, $close) if ($content->{'text'} ne '');
        }
        ($current, $index, $close) = ($current_next, $index_next, $close_next);
    }
}

sub info_default_store_pending($$$;$)
{
   my $line_char_counter = shift;
   my $pending_spaces = shift;
   my $pending_word = shift;
   my $indent_length = shift;

   my $indent_text = '';
   $indent_text = ' ' x $indent_length if (defined($indent_length));

   if ($line_char_counter == 0)
   {
      $pending_spaces = $indent_text . $pending_spaces;
   }
   my $result = $pending_spaces;
   $pending_spaces = '';
   if (defined($pending_word))
   {
      $result .= $pending_word;
      $pending_word = undef;
   }
   $line_char_counter += length($result);
   return ($line_char_counter, $pending_spaces, $pending_word, $result);
}

my $info_default_end_sentence_character = quotemeta('.');
my $info_default_indent_length = 5;
my $info_default_para_indent_length = 3;
my $info_default_first_para_indent = 'none';

sub info_default_output($)
{
   my $info_state = shift;
   my $result = '';
   print STDERR "Storing the stack\n";
   print STDERR "" . Data::Dumper->Dump([$info_state->{'top'}]);
   my ($characters_count, $lines_count);
   ($characters_count, $result, $lines_count) = info_default_process_content($info_state->{'top'}, $info_state);
   $info_state->{'offset_in_file'} += $characters_count;
   $info_state->{'line_count'} += $lines_count;
   info_default_reset_state($info_state) 
       if (!defined($info_state->{'current'}->{'command'}));
   return $result;
}

my %info_default_index_line_string_length;
my %info_default_index_entries;

sub info_default_process_content($$)
{
   my $current_command = shift;
   my $info_state = shift;

   my $length = 0;
   my $result = '';

   my $line_char_counter = 0;
   my $all_line_passed = 0;

   my $pending_spaces = '';
   my $pending_word;
   my $preformatted = 0;
   my $indent_level = 0;
   my $exdent_line = 0;
   my $item_pending;
   my $in_exdent = 0;
   my $in_para = 0;

   my ($current, $index, $close) = ($current_command, 0, 0);

   #print STDERR "info_default_process_content: $current_command\n";
   while(1)
   {
      last if (!defined($current));
      my $content = $current->{'content'}->[$index];
      my $text_added = '';
my  $waiting_for_line_text = 'undef';
$waiting_for_line_text = $info_state->{'waiting_for_line'} if (defined($info_state->{'waiting_for_line'}));
my $line_char_counter_text = 'undef';
$line_char_counter_text = "$line_char_counter" if (defined($line_char_counter));
my $text_length = '';
$text_length = $content->{'length'} if defined($content->{'length'});
my $text_command = '';
$text_command = $content->{'command'} if defined($content->{'command'});
my $in_node_count = 0;
$in_node_count = $info_state->{'line_count'} if defined($info_state->{'line_count'});
      print STDERR "($text_command|$text_length|$close|${all_line_passed}+$in_node_count) preformatted $preformatted, indent_lvl $indent_level exdent_line $exdent_line line_char_counter $line_char_counter_text waiting_for_line $waiting_for_line_text\n";
my $pending_word_text = 'undef';
$pending_word_text = "`$pending_word'" if (defined($pending_word));
print STDERR "         spaces: `$pending_spaces' word: $pending_word_text\n";

      my $indent_length = $indent_level * $info_default_indent_length;
      $indent_length = ($indent_level -1) * $info_default_indent_length
            if ($indent_level and $in_exdent);
      $indent_length = ($info_default_indent_length -2
                        +($indent_level -1)* $info_default_indent_length)
            if ($item_pending);
      
      if ($close)
      {
          if (defined($content->{'end'}))
          {
              $text_added = $content->{'end'};
          }
          # if ending a paragraph, go straight to the text addition 
          # without processing of the end of lines. Same if ending a 
          # quotation or an @example
          if (defined($content->{'command'}))
          {
              if ($info_default_indented_commands{$content->{'command'}})
              {
                  $indent_level--;
                  # don't do that for quotations, quotations already have
                  # end of paragraph end of lines.
                  $text_added = $content->{'end'} if defined($content->{'end'});
                  if ($indent_level > 0 and $complex_format_map->{$content->{'command'}})
                  {
                     $text_added .= "\n";
                  }
                  $info_state->{'waiting_for_line'} = 1 if ($indent_level == 0);
                  goto new_text;
              }
              if ($content->{'command'} eq 'paragraph')
              {
                  $pending_spaces = '';
                  $in_para = 0;
                  $info_state->{'indent_para'} = undef;
                  $text_added = "\n" unless ($line_char_counter == 0);
                  $info_state->{'waiting_for_line'} = 1;
                  # FIXME needed?
                  goto new_text;
              }
              elsif ($content->{'command'} eq 'preformatted')
              {
               # if preformatted doesn't end with a newline, it is added here
                  $text_added = "\n" unless ($line_char_counter == 0);
                  $preformatted--;
              }
          }
      }
      else
      {
          if ($content->{'command'})
          { 
              if ($content->{'command'} eq 'anchor' or $content->{'command'} eq 'image' or $content->{'command'} eq 'index_command')
              {
                  my $pending;
                  ($line_char_counter, $pending_spaces, $pending_word, $pending) = info_default_store_pending($line_char_counter, $pending_spaces, $pending_word, $indent_length);
                  # here spaces out of any environment are ignored.
                  if ($in_para or $preformatted or $pending !~ /^\s*$/)
                  { # this has to be done before the anchor related code
                    # to have the right count.
                      $length += length($pending);
                      $result .= $pending;
                  }
              }
              if ($content->{'command'} eq 'anchor')
              {
                  $content->{'anchor_reference'}->{'info_offset'} = $length + $info_state->{'offset_in_file'};
                  push @{$info_state->{'pending_tags'}}, $content->{'anchor_reference'};
              }
              elsif ($content->{'command'} eq 'index_label')
              {
                  my $index_line_nr = $all_line_passed + $info_state->{'line_count'};
                  my $index_name = $content->{'index_name'};
                  $info_default_index_line_string_length{$index_name} = length($index_line_nr) 
                      if (!defined($info_default_index_line_string_length{$index_name}) or $info_default_index_line_string_length{$index_name} < length($index_line_nr));
print STDERR "RRRRRRRRRRRRR $content->{'index_entry_reference'}->{'texi'}   name: $index_name line: $index_line_nr max: $info_default_index_line_string_length{$index_name}\n";
                  $info_default_index_entries{$content->{'index_entry_reference'}} = { 'index_entry_reference' => $content->{'index_entry_reference'}, 'line_nr' => $index_line_nr, 'index_name' => $index_name };
              }
              elsif ($content->{'command'} eq '*' and !$preformatted)
              {
                 if (defined($pending_word))
                 {
                    $text_added .= $pending_spaces . $pending_word;
                    $pending_word = undef;
                 }
                 # spaces preceding @* are skipped
                 $pending_spaces = '';
                 $text_added .=  $content->{'text'};
                 # just like following spaces
                 ($current, $index, $close) = info_default_skip_spaces($current, $index, $close);
                 goto new_text;
              }
              elsif ($content->{'command'} eq 'paragraph')
              {
                 my $paragraphindent = $Texi2HTML::THISDOC{'paragraphindent'};
                 $paragraphindent = $Texi2HTML::Config::PARAGRAPHINDENT if (!defined($paragraphindent));
                 $paragraphindent = 0 if ($paragraphindent eq 'none');
                 if ($paragraphindent ne 'asis')
                 {
                    ($current, $index, $close) = info_default_skip_spaces($current, $index, $close);
                 }
                 if ($paragraphindent ne 'asis' and $paragraphindent and $line_char_counter == 0 and  !($indent_level) and ($info_state->{'indent_para'} or (!defined($info_state->{'indent_para'}) and ($content->{'paragraph_in_element_nr'} or (defined($Texi2HTML::THISDOC{'firstparagraphindent'}) and $Texi2HTML::THISDOC{'firstparagraphindent'} eq 'insert')))))
                 {
                    $content->{'begin'} = ' ' x $paragraphindent;
                 }
                 $in_para = 1;
              }
              elsif ($content->{'command'} eq 'preformatted')
              {
                  $preformatted++;
                  $in_exdent = 0;
              }
              elsif ($content->{'command'} eq 'exdent')
              {
                  $in_exdent = 1;
              }
              elsif ($content->{'command'} eq 'indent')
              {
                  $info_state->{'indent_para'} = 1;
              }
              elsif ($content->{'command'} eq 'noindent')
              {
                  $info_state->{'indent_para'} = 0;
              }
              elsif ($content->{'command'} eq 'image')
              {
                  $text_added .=  $content->{'text'};
                  goto new_text;
              }
              elsif ($content->{'command'} eq 'item' and exists $format_map{$content->{'format'}})
              {
                  $item_pending = 1;
              }
              if ($info_default_indented_commands{$content->{'command'}})
              {
                  $info_state->{'waiting_for_line'} = 0 if ($indent_level == 0);
                  $indent_level++;
              }
          }

          if (defined($content->{'begin'}))
          {
              $text_added .= $content->{'begin'};
          }

          if ($content->{'length'})
          {
              if ($in_para and !$in_exdent)
              {
                  if (chomp($content->{'text'}))
                  {
                      $content->{'text'} =~ s/(\s*)$/ /;
                      if ($content->{'text'} =~ /$info_default_end_sentence_character $/)
                      {
                          $content->{'text'} .= ' ';
                      }
                  }
                  $text_added .= $content->{'text'};
              } # ignore spaces outside of paragraphs and preformatted
              elsif ($preformatted)
              {
                  $text_added .= $content->{'text'};
              }
              else
              {
                  my $chomped_text = $content->{'text'};
                  if ($chomped_text =~ /^\s*$/ and chomp($chomped_text))
                  {
                      if ($info_state->{'waiting_for_line'})
                      {
                           $text_added ="\n";
                           $info_state->{'waiting_for_line'} = 0;
                  #         $text_added .= "\n" if ($line_char_counter != 0);
                      }
                  }
                  else
                  { # exdent, item not in paragraph nor in preformatted
                       $text_added .= $content->{'text'};
                       $info_state->{'waiting_for_line'} = 0;
                  }
              }
# unless (!defined($line_char_counter) and !$preformatted and $content->{'text'} =~ /^\s*$/);
          }
      }
      if (!$preformatted and !$in_exdent)
      {
          # the line_passed returned here are not used, since they are computed
          # below.
          my $dummy_line_passed;
          ($line_char_counter, $pending_spaces, $pending_word, $dummy_line_passed, $text_added) = info_default_process_text($text_added, $line_char_counter, $pending_spaces, $pending_word, $indent_length, $in_para) if ($text_added ne '');
      }
      else
      {
          my $chomped_text = $text_added;
          chomp($chomped_text);
print STDERR "text_added `$text_added' line_char_counter $line_char_counter\n";
          if ($text_added ne '' and $chomped_text ne '' and $line_char_counter == 0)
          {
print STDERR "                     indent_length $indent_length\n";
              $text_added =  ' ' x $indent_length.$text_added;
          }
          $line_char_counter += length($text_added);
      }
    new_text:
      # from here, the next cmmand is available
      ($current, $index, $close) = info_default_iterator_next($current, $index, $close);
print STDERR "ADDING `$text_added'\n" if ($text_added ne '');
      if ($text_added ne '')
      {
         $item_pending = undef;
         if ($exdent_line)
         {
             $exdent_line = 0;
             $in_exdent = 1;
         }
      }
      $result .= $text_added;
      $length += length($text_added);
      my ($line_passed, $end_of_line, $last_line) = info_default_count_lines($text_added);

      if ($end_of_line)
      {
         $line_char_counter = 0;
         $in_exdent = 0;
      }
      else
      {
         if ($line_passed)
         {# in that case we added more than one line, the $line_char_counter
          # is reset to the last line length.
            $line_char_counter = length($last_line);
         }
      }
      $all_line_passed += $line_passed;
   }
   return ($length, $result, $all_line_passed);
}

my $state_nr = 0;
sub info_default_get_state($)
{
   my $state = shift;
   if (!exists $info_default_state_map{$state})
   {
print STDERR "NEW state\n";
      my ($current_command, $top_stack);
      $info_default_state_map{$state} = {};
      info_default_reset_state($info_default_state_map{$state});
      $info_default_state_map{$state}->{'nr'} = $state_nr;
      $info_default_state_map{$state}->{'state'} = $state;
      $state_nr++;
   }
my $text_inside = 0;
$text_inside = $state->{'inside_document'} if (defined($state->{'inside_document'}));
my $text_outside = 0;
$text_outside = $state->{'outside_document'} if (defined($state->{'outside_document'}));
my $text_duplicate = 0;
$text_duplicate = 0;
$text_duplicate =  $state->{'duplicated'} if (defined($state->{'duplicated'}));
print STDERR "RETURN state $state $info_default_state_map{$state} $text_inside $text_outside $text_duplicate $info_default_state_map{$state}->{'nr'}\n";
   return $info_default_state_map{$state};
}

sub info_default_open_command($$$$$)
{
   my $state = shift;
   my $command = shift;
   my $no_close = shift;
   my $no_open = shift;
   my $line_nr = shift;

   my $index = 0;
   
   $info_default_state = info_default_get_state($state);
   # index in the parent content list
   $index = scalar(@{$info_default_state->{'current'}->{'content'}}) 
       if (defined($info_default_state->{'current'}->{'content'}));
   my $new_command = {'command' => $command, 'parent' => $info_default_state->{'current'}, 'index_in_parent' => $index };
   push @{$info_default_state->{'current'}->{'content'}}, $new_command;
   $info_default_state->{'current'} = $new_command;
   print STDERR "Opened $command ". 
     "\n";
#     Data::Dumper->Dump([$info_default_state->{'top'}]);
}

sub info_default_close_command($$$$$$$$$;$)
{
   my $state = shift;
   my $command_stack = shift;
   my $command = shift;
   my $no_close = shift;
   my $no_open = shift;
   my $line_nr = shift;
   my $begin = shift;
   my $text = shift;
   my $end = shift;
   my $additional_entries = shift;

   $no_open = 0 if (!defined($no_open));
   $no_close = 0 if (!defined($no_close));
   $state = $Texi2HTML::THISDOC{'state'} if (!defined($state));
   my $info_state = info_default_get_state($state);
   #print STDERR "" . Data::Dumper->Dump([$current_command]);
   print STDERR "Closing $command ".
     "\n";
   if (!defined($info_state->{'current'}))
   {
      print STDERR "info_default_state->{'current'} not defined\n";
   }
   elsif (!defined($info_state->{'current'}->{'command'}))
   {
      print STDERR "info_default_state->{'current'}->{'command'} not defined\n";
   }
   elsif ($command ne $info_state->{'current'}->{'command'})
   {
     print STDERR "Was waiting for $info_default_state->{'current'}->{'command'}\n";
   }
#     Data::Dumper->Dump([$info_default_state->{'top'}]);
   #return if $no_close;
   $info_state->{'current'}->{'no_close'} = 1 if ($no_close);
   $info_state->{'current'}->{'begin'} = $begin;
   $info_state->{'current'}->{'text'} = $text;
   $info_state->{'current'}->{'end'} = $end;
   if (defined($additional_entries))
   {
       foreach my $key (keys(%$additional_entries))
       {
           $info_state->{'current'}->{$key} = $additional_entries->{$key};
       }
   }

   if ($info_default_leaf_command{$command})
   {
      my $saved_offset_in_file = $info_state->{'offset_in_file'};
      my $saved_line_count = $info_state->{'line_count'};
      my $result = return info_default_output($info_state);
      $info_state->{'offset_in_file'} = $saved_offset_in_file;
      $info_state->{'line_count'} = $saved_line_count;
      $info_state->{'current'}->{'text'} = $result;
      $info_state->{'current'}->{'length'} = length($result);
      return '';
   }
   $info_state->{'current'} = $info_state->{'current'}->{'parent'};

   return info_default_output($info_state)
     if (!defined($info_state->{'current'}->{'command'}));
   return '';
   
}

sub info_default_store_text($$;$$)
{
   my $state = shift;
   my $text = shift;
   my $command = shift;
   my $additional_entries = shift;
#   $state = $Texi2HTML::THISDOC{'state'} if (!defined($state));

   my $info_state = info_default_get_state($state);
   my $len = length($text);
   # When state is 'outside_document' it means that we are outputting some
   # text as part of special regions but not inside the document.
   # when state is duplicated, it may mean that we risk storing some
   # output that is not directly outputted to the document, for example
   # node names.
   # however in some cases the state is duplicated, but we want to store
   # the text. In that case the command is used.
#   return 0 if (!(defined($command) and $command eq 'menu_entry') and ((!$state->{'inside_document'} and !$state->{'outside_document'}) or ($state->{'duplicated'} and $state->{'inside_document'})));
   return '' if ($len == 0 and !defined($command));
   my $command_text = '';
   $command_text = "\[$command\]" if (defined($command));
   print STDERR "Storing text${command_text}($len) $text\n";
   my $text_stored = {'text' => $text, 'length' => $len};
   $text_stored->{'command'} = $command if (defined($command));
   if (defined($additional_entries))
   {
       foreach my $key (keys(%$additional_entries))
       {
           $text_stored->{$key} = $additional_entries->{$key};
       }
   }
   push @{$info_state->{'current'}->{'content'}}, $text_stored;
   return info_default_output($info_state)
     if (!defined($info_state->{'current'}->{'command'}));
   return '';
}

sub info_default_begin_format_texi($$$)
{
   my $command = shift;
   my $line = shift;
   my $state = shift;
   info_default_open_command($state,$command, undef, undef, undef);
   return $line;
}

sub info_default_begin_style_texi($$$$)
{
   my $command = shift;
   my $state = shift;
   my $stack = shift;
   my $real_style_command = shift;
   info_default_open_command($state,$command, undef, undef, undef)
     unless ($info_default_accent_commands{$command} or exists $things_map{$command});
#      if ($real_style_command);
}

sub info_default_begin_paragraph_texi($$$)
{
   my $command = shift;
   my $paragraph_macros = shift;
   my $paragraph_command = shift;
   print STDERR "begin_paragraph $command\n";
   my $state = shift;
   my $stack = shift;
   info_default_open_command($state,$command, undef, undef, undef);
   foreach my $style_command (@$paragraph_macros)
   {
     print STDERR "para stack: $style_command->{'style'}\n";
     info_default_open_command($state,$style_command->{'style'}, undef, undef, undef);
     $info_default_state->{'current'}->{'no_open'} = 1;
   }
}

sub info_default_simple_command($$$$)
{
    my $command = shift;
    my $in_preformatted = shift;
    my $line_nr = shift;
    my $state = shift;

    my $result = $simple_map{$command};
    return info_default_store_text($state,$result,$command);
    #return '' if info_default_store_text($state,$result,$command);
    #return $result;
}


sub info_default_thing_command($$$$$)
{
    my $command = shift;
    my $text = shift;
    my $in_preformatted = shift;
    my $line_nr = shift;
    my $state = shift;

    my $result = $things_map{$command};
    #return info_default_close_command($state, undef, $command, undef, undef, $line_nr, $result, $text, '');
    return info_default_store_text($state, $result, $command);
#    return $result . $text;
}


sub info_default_style($$$$$$$$$)
{
   my $style = shift; 
   my $command = shift;
   my $text = shift;
   my $args = shift;
   my $no_close = shift;
   my $no_open = shift;
   my $line_nr = shift;
   my $state = shift;
   my $command_stack = shift;

   my $begin = '';
   my $end = '';

   if ($info_default_leaf_command{$command})
   {
      my $style_index = 0;
      my @formatted_args = ();
      foreach my $arg (@$args)
      {
         my $arg_style = $style->{'orig_args'}->[$style_index];
         if ($arg_style eq 'normal')
         {
            push @formatted_args, main::substitute_line($arg);
         }
         elsif ($arg_style eq 'code')
         {
            push @formatted_args, main::substitute_line($arg, {'code_style' => 1});
         }
         else
         {
            print STDERR "Unknown arg style($style_index) $arg_style for $command\n";
         }
         $style_index++;
      }
      $args = \@formatted_args; 
   }
   if (defined($style->{'function'}))
   {
      $text = &{$style->{'function'}}($command, $args, $command_stack, $state, $line_nr);
   }
   if (defined($style->{'begin'}) and !$no_open)
   {
      $begin = $style->{'begin'};
   }
   if (defined($style->{'end'}) and !$no_close)
   {
      $end = $style->{'end'};
   }
   unless($special_style{$command} or ($command eq 'cmd_line') or $info_default_accent_commands{$command} or ($command eq 'hyphenation') or $info_default_leaf_command{$command})
   {
      return info_default_close_command($state, $command_stack, $command, $no_close, $no_open, $line_nr, $begin, $text, $end);
   }
   # this is for *ref, images and footnotes
   if (($special_style{$command} or $info_default_leaf_command{$command}) and $command ne 'anchor')
   {
       return info_default_store_text ($state, $begin.$text.$end, $command);
   }
   
   return $begin.$text.$end;
}

sub info_default_print_page_head($)
{
    my $fh = shift;
    my $setfilename = $Texi2HTML::THISDOC{'setfilename'} if (defined($Texi2HTML::THISDOC{'setfilename'}));
    $setfilename = $Texi2HTML::THISDOC{'file_base_name'}.$EXTENSION if (!defined($setfilename));
    #my $result = "This is $setfilename, produced by $Texi2HTML::THISDOC{program} from $Texi2HTML::THISDOC{'input_file_name'}.\n\n";
    # this is wrong, $Texi2HTML::THISDOC{'input_file_name'} should be used 
    # directly, but then tests are not reproducible in out of source builds
    my $basename = $Texi2HTML::THISDOC{'input_file_name'};
    $basename =~ s/^.*\///;
    my $result = "This is $setfilename, produced by makeinfo version 4.13 from $basename. ";
    my $dummy;
    ($dummy, $dummy, $dummy, $dummy, $result) = info_default_process_text($result, 0, '', undef, undef, 1);
    $result .= "\n\n";
    $result .= "$Texi2HTML::THISDOC{'copying_comment'}";
    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);
    $info_state->{'offset_in_file'} = length($result);
    print $fh $result;
}

sub info_default_paragraph($$$$$$$$$$$$)
{
    my $text = shift;
    my $align = shift;
    my $indent = shift;
    my $paragraph_command = shift;
    my $paragraph_command_formatted = shift;
    my $paragraph_number = shift;
    my $format = shift;
    my $item_nr = shift;
    my $enumerate_style = shift;
    my $number = shift;
    my $command_stack_at_end = shift;
    my $command_stack_at_begin = shift;

    my $top_stack = '';
    $top_stack = $command_stack_at_begin->[-1] if (scalar (@$command_stack_at_begin));

    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);
    $info_state->{'paragraph_in_element_nr'}++;
    if (defined($command_stack_at_begin->[0]) and $command_stack_at_begin->[0] eq 'footnote' and $info_state->{'paragraph_in_element_nr'} <= 1)
    {
        
    }
    return info_default_close_command(undef, undef, 'paragraph', undef, undef, undef, '', undef, undef, {'paragraph_in_element_nr' => ($info_state->{'paragraph_in_element_nr'} -1), 'top_stack' => $top_stack});
}

sub info_default_preformatted($$$$$$$$$$$$)
{
    my $text = shift;
    my $pre_style = shift;
    my $class = shift;
    my $leading_command = shift;
    my $leading_command_formatted = shift;
    my $preformatted_number = shift;
    my $format = shift;
    my $item_nr = shift;
    my $enumerate_style = shift;
    my $number = shift;
    my $command_stack_at_end = shift;
    my $command_stack_at_begin = shift;

#    if (defined($preformatted_number) and defined($$preformatted_number))
#    {
#        $$preformatted_number++;
#    }
    # a paragraph after a preformatted is indented. So looks like 
    # preformatted count as paragraphs.
    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);
    $info_state->{'paragraph_in_element_nr'}++;
    return info_default_close_command(undef, undef, 'preformatted', undef, undef, undef, undef, undef, undef);
} 


my %default_info_level_to_symbol = (
  0 => '*',
  1 => '*',
  2 => '=',
  3 => '-',
  4 => '.'
);

sub info_default_node_line($$)
{
    my $element = shift;
    my $info_state = shift;
    my $result = "\x{1F}\nFile: $element->{'file'},  Node: $element->{'text'}";
    if (defined($element->{'NodeNext'}))
    {
       $result .= ','.&$I('  Next: %{node_next}', {'node_next' => $element->{'NodeNext'}->{'text'}});
    }
    if (defined($element->{'NodePrev'}))
    {
       $result .= ','.&$I('  Prev: %{node_prev}', {'node_prev' => $element->{'NodePrev'}->{'text'}});
    }
    if (defined($element->{'NodeUp'}))
    {
       $result .= ','.&$I('  Up: %{node_up}', {'node_up' => $element->{'NodeUp'}->{'text'}});
    }
    $result .= "\n\n";
    $info_state->{'line_count'} = 3;
    $info_state->{'offset_in_file'} += length($result);
    return $result;
}

my $info_default_footnote_index;
my $info_default_current_node;
sub info_default_element_heading($$$$$$$$$$$$)
{
    my $element = shift;
    my $command = shift;
    my $texi_line = shift;
    my $line = shift;
    my $in_preformatted = shift;
    my $one_section = shift;
    my $element_heading = shift;
    my $first_in_page = shift;
    my $is_top = shift;
    my $previous_is_top = shift;
    my $command_line = shift;
    my $element_id = shift;
    my $new_element = shift;

    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);

    # FIXME use $element or $Texi2HTML::THIS_ELEMENT? Main program should 
    # ensure they are the same. 
    if ($new_element and ($element ne $new_element or !$element->{'node'}))
    {
        die "There is a new element, but element $element->{'texi'} is not a node or not the new element\n";
    }
    return &$heading($element, $command, $texi_line, $line, $in_preformatted, $one_section, $element_heading) unless ($new_element);

print STDERR "HHHHHHHHHHHHHHH node $info_state->{'nr'}\n";
    my $before = '';
    $element->{'info_offset'} = $info_state->{'offset_in_file'};
    push @{$info_state->{'pending_tags'}}, $element;

    my $result = info_default_node_line($element, $info_state);

    $info_default_footnote_index = 0;
    #$info_default_current_node = $Texi2HTML::THIS_ELEMENT;
    $info_default_current_node = $element;
    
    return $before.$result;
}

sub info_default_heading($$$$$;$$)
{
    my $element = shift;
    my $command = shift;
    my $texi_line = shift;
    my $line = shift;
    my $in_preformatted = shift;
    my $one_section = shift;
    my $element_heading = shift;

    die "Heading called for a node\n" if ($element->{'node'});
    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);
print STDERR "HHHHHHHHHHHHHHH section $info_state->{'nr'}\n";
    $info_state->{'paragraph_in_element_nr'} = 0;
    my $text = "$element->{'text'}";
    # to do the same than makeinfo a trailing dot in section number is removed
    $text =~ s/^(\w+)\. /$1 /;
    $text = "Annexe $text" if ($element->{'tag'} =~ /appendix/ and $element->{'level'} <= 1);
    my $heading = $text . "\n" . 
       ($default_info_level_to_symbol{$element->{'level'}} x length($text)) . "\n";
    if (length($text))
    {
       $heading .= "\n";
       $info_state->{'line_count'}++;
    }
    if ($info_state->{'waiting_for_line'})
    {
       $heading = "\n" .$heading;
       $info_state->{'waiting_for_line'} = 0;
       $info_state->{'line_count'}++;
    }
    # FIXME use state for headings appearing somewhere strange. + maybe
    # waiting_for_line should also be used for headings
    $info_state->{'offset_in_file'} += length($heading);
    $info_state->{'line_count'} += 2;
    return $heading;
}

sub info_default_normal_text($$$$$$;$)
{
   my $text = shift;
   my $in_raw_text = shift; # remove_texi
   my $in_preformatted = shift;
   my $in_code = shift;
   my $in_simple = shift;
   my $style_stack = shift;
   my $state = shift;

#Data::Dumper->Dump([$state]);

#print STDERR "info_default_normal_text $text $in_preformatted $in_code \n";
   $text = uc($text) if (in_cmd($style_stack, 'sc'));
#   $text = &$protect_text($text) unless($in_raw_text);
   if (! $in_code and !$in_preformatted)
   {
       $text =~ s/---/\x{1F}/g;
       $text =~ s/--/-/g;
       $text =~ s/\x{1F}/--/g;
       $text =~ s/``/"/g;
       $text =~ s/\'\'/"/g;
   }
   else
   {
       # to be like texinfo
#       my $special_code = 0;
#       $special_code = 1 if (in_cmd($style_stack, 'code') or 
#           in_cmd($style_stack, 'example') or in_cmd($style_stack, 'verbatim'));
#       $text =~ s/'/\&rsquo\;/g unless ($special_code and exists($main::value{'txicodequoteundirected'}));
#       $text =~ s/`/\&lsquo\;/g unless ($special_code and exists($main::value{'txicodequotebacktick'}));
   }
   # accented characters are not handled as text, but when the last 
   # accent command on the stack is closed.
   if ($style_stack and @$style_stack and $info_default_accent_commands{$style_stack->[-1]})
   {
      return $text;
   }
   return info_default_store_text($state,$text);
   # We never store in the stack text in raw text (remove_texi).
#   unless ($in_raw_text)
#   {
#      return '' if (info_default_store_text($state,$text));
#   }
#   return $text;
}

# this is not called in preformatted
sub info_default_empty_line($$)
{
    my $text = shift;
    my $state = shift;
    #ignore the line if it just follows a deff
    #return '' if ($state->{'deff_line'});
    return info_default_store_text($state,$text);
#    return '';
}

# change interface?
sub info_default_anchor_label($$$)
{
    my $id = shift;
    my $anchor_text = shift;
    my $anchor_reference = shift;
    # give it as an argument?
    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state($state);
    #return if (!$state->{'inside_document'} and !$state->{'outside_document'});
    print STDERR "Storing anchor $anchor_reference->{'text'}\n";
    my $anchor_stored = {'command' => 'anchor', 'anchor_reference' => $anchor_reference};
    push @{$info_state->{'current'}->{'content'}}, $anchor_stored;
   return info_default_output($info_state)
     if (!defined($info_state->{'current'}->{'command'}));
   return '';
}

sub info_default_acronym_like($$$$$$)
{
    my $command = shift;
    my $acronym_texi = shift;
    my $acronym_text = shift;
    my $with_explanation = shift;
    my $explanation_lines = shift;
    my $explanation_text = shift;
    my $explanation_simply_formatted = shift;

   if ($with_explanation)
   {
       return "$acronym_text ($explanation_text)";
   }
   else
   {
       return "$acronym_text";
   }
}


sub info_default_print_page_foot($)
{
   my $fh = shift;
   my $state = $Texi2HTML::THISDOC{'state'};
   my $info_state = info_default_get_state ($state);
   return unless (defined ($info_state->{'pending_tags'}));
   # makeinfo seems to add systematically an additional \n, done just below
   print $fh "\n\x{1F}\nTag Table:\n";
   # 
   foreach my $element (@{$info_state->{'pending_tags'}})
   {
      my $prefix;
      $prefix = 'Node' if ($element->{'node'});
      $prefix = 'Ref' if ($element->{'anchor'});
      print $fh "$prefix: $element->{'text'}\x{7F}$element->{'info_offset'}\n";
   }
   print $fh "\x{1F}\nEnd Tag Table\n";
}

sub info_default_print_Top_footer($$$)
{
    my $fh = shift;
    my $end_page = shift;
    my $element = shift;
    if ($end_page)
    {
        &$print_page_foot($fh);
    }
}

sub info_default_footnote_texi($$$)
{
    my $text = shift;
    my $state = shift;
    my $style_stack = shift;
    
    $info_default_footnote_index++;
    return "($info_default_footnote_index) $text";
}
   

my @info_default_pending_footnotes;
sub info_default_print_section
{
    my $fh = shift;
    my $first_in_page = shift;
    my $previous_is_top = shift;
    my $element = shift;
    my $nw = main::print_lines($fh);
    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);
    if ($info_state->{'waiting_for_line'})
    {
       my $end = "\n";
       $info_state->{'offset_in_file'} += length($end);
       $info_state->{'line_count'}++;
       $info_state->{'waiting_for_line'} = 0;
       print $fh "$end";
    }
    if (@info_default_pending_footnotes)
    {
        my $footnote_text;
        if ($SEPARATED_FOOTNOTES)
        {
            my $node_ref = $info_default_current_node;
            $node_ref = {'text' => 'no node', 'file' => ''} if (!defined($node_ref));
            my $footnote_element = { 'NodeUp' => $node_ref, 
                       'text' => $node_ref->{'text'} . "-Footnotes", 
                       'file' => $node_ref->{'file'},
                       'info_offset' => $info_state->{'offset_in_file'},
                       'node' => 1
                 };
            push @{$info_state->{'pending_tags'}}, $footnote_element;
            $footnote_text = info_default_node_line($footnote_element, $info_state); 
        }
        else
        {
            $footnote_text = "   ---------- Footnotes ----------\n\n";
            $info_state->{'offset_in_file'} += length($footnote_text);
        }
        while (@info_default_pending_footnotes)
        {
    #push @info_default_pending_footnotes, [$lines, $footnote_text, ${info_default_footnote_index}, $node_name, $footnote_info_state];
            my $footnote = shift @info_default_pending_footnotes;
            my $foot_nr = $footnote->{'footnote_index'};
            my $node_name = $footnote->{'node_name'};
            my $lines = $footnote->{'lines'};
            push @{$info_state->{'pending_tags'}}, {'anchor' => 1, 'text' => "${node_name}-Footnote-${foot_nr}", 'info_offset' => $info_state->{'offset_in_file'} };
            my $footnote_info_state = $footnote->{'footnote_info_state'};
            my $footnote_result = shift @{$lines};
            my $initial_length = length($footnote_result);
            $footnote_result =~ s/^\s*//;
            #$footnote_result = "   ($foot_nr) " . $footnote_result;
            $footnote_result = "   " . $footnote_result;
            foreach my $footnote_pending_tags(@{$footnote_info_state->{'pending_tags'}})
            {
               $footnote_pending_tags->{'info_offset'} += $info_state->{'offset_in_file'} + length($footnote_result) - $initial_length;
               push @{$info_state->{'pending_tags'}}, $footnote_pending_tags;
            }
            my $line;
            while (@$lines)
            {
               $line = shift @$lines;
               $footnote_result .= $line;
            }
            my ($line_passed, $end_of_line, $last_line) = info_default_count_lines($footnote_result);
            if ($line_passed == 0)
            {# certainly out of paragraph commands
               $footnote_result =~ s/\s*$//;
               $footnote_result .= "\n";
               $line_passed = 1;
            }
            $footnote_result .= "\n";
            $info_state->{'offset_in_file'} += length($footnote_result);
            $info_state->{'line_count'} += $line_passed +1;
            $footnote_text .= $footnote_result;
        }
        print $fh "$footnote_text";
    }
}

sub info_default_end_section($$$)
{
    my $fh = shift;
    my $end_foot_navigation = shift;
    my $element = shift;
}

sub info_default_one_section($$)
{
    my $fh = shift;
    my $element = shift;
    &$print_section($fh, 1, 0, $element);
    &$print_page_foot($fh);
}

sub info_default_begin_special_region($$$)
{
    my $region = shift;
    my $state = shift;
    my $lines = shift;
    my $info_state = info_default_get_state ($state);
    if ($state->{'outside_document'})
    {
        $info_state->{'paragraph_in_element_nr'} = 0;
    }
}

sub info_default_end_special_region($$$)
{
    my $region = shift;
    my $state = shift;
    my $text = shift;
    my $info_state = info_default_get_state ($state);
    my $end = '';
    if ($info_state->{'waiting_for_line'})
    {
       $end = "\n";
       $info_state->{'offset_in_file'} += length($end);
       $info_state->{'waiting_for_line'} = 0;
    }
    return $text.$end;
}

sub info_default_menu_link($$$$$$$$)
{
    my $entry = shift;
    my $state = shift;
    my $href = shift;
    my $node = shift;
    my $title = shift;
    my $ending = shift;
    my $has_title = shift;
    my $command_stack = shift;
    my $preformatted = shift;

    $title = '' unless ($has_title);
    $title .= ':' if ($title ne '');
    my $result = "$MENU_SYMBOL$title$node$ending";
#print STDERR "$result return 0 if ((!$state->{'inside_document'} and !$state->{'outside_document'}) or ($state->{'duplicated'} and $state->{'inside_document'}))\n";
    return info_default_store_text($state,$result,'menu_entry');
#    return '' if info_default_store_text($state,$result,'menu_entry');
#    #print STDERR "GGGGGGGGGG ${ending} GGGGGGG $result\n";
#    return $result;
}

# not used, menu is a normal preformatted command
#sub info_default_menu_command($$$)
#{
#    my $format = shift;
#    my $text = shift;
#    my $in_preformatted = shift;
#print STDERR "MENU $format\n";
#    return info_default_close_command(undef, $format, undef, undef, undef, "* Menu:\n", undef, "\n");
#}   

sub info_default_complex_format($$)
{
    my $name = shift;
    my $text = shift;
    my ($begin, $end);
    if ($name eq 'menu')
    {
        $begin = "* Menu:\n\n";
        $end = "\n";
    }
    return info_default_close_command(undef, undef, $name, undef, undef, undef, $begin, undef, $end);
}

sub info_default_quotation($$$$)
{
    my $command = shift;
    my $text = shift;
    my $argument_text = shift;
    my $argument_text_texi = shift;

    return info_default_close_command(undef, undef, $command, undef, undef, undef, undef, undef, undef);
}

sub info_default_misc_commands($$$$$)
{
    my $command = shift;
    my $line = shift;
    my $pass = shift;
    my $stack = shift;
    my $state = shift;

    return ($line, 0, undef, undef) unless ($pass == 2);
    return ($line, 0, undef, undef) unless ($command eq 'exdent' or $command eq 'noindent' or $command eq 'indent');
    my ($result_line, $text, $args) = &$preserve_misc_command ($line, $command);
    info_default_store_text($state,'',$command);
    return ($result_line, 1, '', undef);
}

sub info_default_external_ref($$$$$$$$)
{
    my $type = shift;
    my $section = shift;
    my $book = shift;
    my $file_node = shift;
    my $href = shift;
    my $cross_ref = shift;
    my $args_texi = shift;
    my $formatted_args = shift;

    return info_default_inforef($formatted_args) if ($type eq 'inforef');
    return info_default_normal_reference($type, $formatted_args);
}

sub info_default_internal_ref($$$$$$$)
{
    my $type = shift;
    my $href = shift;
    my $short_name = shift;
    my $name = shift;
    my $is_section = shift;
    my $args_texi = shift;
    my $formatted_args = shift;

    return info_default_inforef($formatted_args) if ($type eq 'inforef');
    return info_default_normal_reference($type, $formatted_args);
}

sub info_default_normal_reference($$)
{
    my $command = shift;
    my $formatted_args = shift;
    for (my $i = 0; $i < scalar(@$formatted_args); $i++)
    {
       $formatted_args->[$i] = undef if (defined($formatted_args->[$i]) and 
          $formatted_args->[$i] =~ /^\s*$/);
    }
    my $node = $formatted_args->[0];
    my $name = $formatted_args->[1];
    $name =  $formatted_args->[2] if (!defined($name));
    my $file = $formatted_args->[3];
    $file = '' if (!defined($file) and defined($formatted_args->[4]));
    $name = $node if (!defined($name) and defined($file));
    my $result = '*note ';
    $result = '*Note ' if ($command eq 'xref');
    if (defined($name))
    {
       $result .= "${name}: ";
       $result .= "($file)" if (defined($file));
       $result .= "$node";
       $result .= '.' if ($command eq 'pxref');
    }
    else
    {
       $result .= "${node}::";
    }
    return $result;
}

sub info_default_inforef($)
{
    my $formatted_args = shift;
    return info_default_normal_reference('ref', [$formatted_args->[0], $formatted_args->[1], undef, $formatted_args->[2], 'dumb manual name']);
}

sub info_default_image_files($$$$)
{
    my $base = shift;
    my $extension = shift;
    my $texi_base = shift;
    my $texi_extension = shift;
    my @files = ();
    return @files if (!defined($base) or ($base eq ''));

    if (defined($extension) and ($extension ne ''))
    {
        push @files, ["${base}$extension", "${texi_base}$extension"];
        push @files, ["$base.$extension", "$texi_base.$extension"];
    }
    foreach my $ext (@IMAGE_EXTENSIONS)
    {
        push @files, ["$base.$ext", "$texi_base.$ext"];
    }
    return @files;
}

sub info_default_image($$$$$$$$$$$$$$$$)
{
    my $file = shift;
    my $base = shift;
    my $preformatted = shift;
    my $file_name = shift;
    my $alt = shift;
    my $width = shift;
    my $height = shift;
    my $raw_alt = shift;
    my $extension = shift;
    my $working_dir = shift;
    my $file_path = shift;
    my $in_paragraph = shift;
    my $file_locations = shift;
    my $base_simple_format = shift;
    my $extension_simple_format = shift;
    my $file_name_simple_format = shift;

    my $txt_path;
    my $found_file;

    my @extensions = @IMAGE_EXTENSIONS;
    if (defined($extension) and ($extension ne ''))
    {
        unshift @extensions, ".$extension";
        unshift @extensions, "$extension";
    }
    foreach my $file_location (@$file_locations)
    {
        my ($file_located, $path, $file_simple_format) = @$file_location;
        my $extension = shift @extensions;
        if (defined($path))
        {
           if ($extension eq 'txt' and !defined($txt_path))
           {
              $txt_path = $path;
           }
           elsif (!defined($found_file))
           {
              $found_file = [$file_located, $extension, $file_simple_format];
           }
        }
    }

    my $text;
    if (defined($txt_path))
    {
       if (open(TXT, "<$txt_path"))
       {
          if (defined($Texi2HTML::THISDOC{'IN_ENCODING'}) and $USE_UNICODE)
          {
              binmode(TXT, ":encoding($Texi2HTML::THISDOC{'IN_ENCODING'})");
          }
          $text='[';
          while (my $img_txt = <TXT>)
          {
              $text .= $img_txt;
          }
          $text .= ']';
          close(TXT);
       }
       else
       {
          main::echo_warn ("\@image file `$txt_path' unreadable: $!");
       }
    }
    else
    {
        main::echo_warn ("Cannot find \@image file `$base.txt'");
    }
    if (defined($found_file))
    {
        my $result = "\x{00}\x{08}[image src=\"$found_file->[2]\"";
        $result .= " alt=\"$alt\"" if (defined($alt));
        $result .= " text=\"$text\"" if (defined($text));
        $result .= "\x{00}\x{08}]";
        return $result;
    }
    return $text if (defined($text));
    return '';
}

sub info_default_print_index($$)
{
    my $text = shift;
    my $name = shift;
    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state ($state);
    my $before = '';
    if ($info_state->{'waiting_for_line'})
    {
       $before = "\n";
       $info_state->{'offset_in_file'} += length($before);
       $info_state->{'line_count'}++;
       $info_state->{'waiting_for_line'} = 0;
    }
    return $before if (!defined($text));
    my $result = "\x{00}\x{08}[index\x{00}\x{08}]\n* Menu:\n\n" .$text."\n";
    $info_state->{'offset_in_file'} += length($result);
    # FIXME set waiting_for_line?
    my ($line_passed, $end_of_line, $last_line) = info_default_count_lines($result);
    $info_state->{'line_count'} += $line_passed;
    return $before.$result;
}

sub info_default_index_letter($$$)
{
     my $letter = shift;
     my $id = shift;
     my $text = shift;
     return $text;
}

sub info_default_index_entry_label($$$$$$$$)
{
    my $identifier = shift;
    my $preformatted = shift;
    my $entry = shift;
    my $index_name = shift;
    my $index_command = shift;
    my $texi_entry = shift;
    my $formatted_entry = shift;
    my $index_entry_ref = shift;

    my $state = $Texi2HTML::THISDOC{'state'};
    my $info_state = info_default_get_state($state);
    #return if (!$state->{'inside_document'} and !$state->{'outside_document'});
    print STDERR "Storing index entry $formatted_entry\n";
    my $index_entry_stored = {'command' => 'index_label', 'index_entry_reference' => $index_entry_ref, 'index_command' => $index_command, 'index_name' => $index_name};
    push @{$info_state->{'current'}->{'content'}}, $index_entry_stored;
   return info_default_output($info_state)
     if (!defined($info_state->{'current'}->{'command'}));
   return '';
}

my $info_default_index_length_to_node = 41;
sub info_default_index_entry($$$$$$$$)
{
    my $text_href = shift;
    my $entry = shift;
    my $element_href = shift;
    my $element_text = shift;
    my $entry_file = shift;
    my $current_element_file = shift;
    my $entry_target = shift;
    my $entry_element_target = shift;
    my $index_entry_ref = shift;

    $entry = main::substitute_line($index_entry_ref->{'texi'});

    my $result = "* $entry: ";
    if (length($result) < $info_default_index_length_to_node)
    {
       $result .= ' ' x($info_default_index_length_to_node - length($result));
    }
    $result .= $element_text . '.';
    my $info_index_entry_ref = $info_default_index_entries{$index_entry_ref};
    my $line_nr = $info_index_entry_ref->{'line_nr'};
    # this happens for index entries appearing after @printindex. In that case
    # it is consideered that they are at the beginning of the node.
    $line_nr = 4 if (!defined($line_nr));
    my $max_len = $info_default_index_line_string_length{$info_index_entry_ref->{'index_name'}};
    my $line_nr_spaces = sprintf("%${max_len}d", $line_nr);
    my $line_part = "(line ${line_nr_spaces})";
#print STDERR "GGGGGGGGGG name: $info_index_entry_ref->{'index_name'} max: ${max_len} line_nr: `$line_nr' line_nr_spaces `$line_nr_spaces' $line_part \n";
    if (length($result)+length($line_part) +1 >  $info_default_max_column)
    {
        $result .= "\n" . ' ' x ($info_default_max_column - length($line_part)) ;
    }
    else
    {
        $result .= ' ' x ($info_default_max_column - length($line_part) - length($result));
    }
    $result .= "$line_part\n";

    return $result;
}

sub info_default_index_summary($$)
{
    my $alpha = shift;
    my $nonalpha = shift;

    return '';
}

sub info_default_summary_letter
{
    return '';
}

sub info_default_foot_line_and_ref($$$$$$$$)
{
    my $foot_num = shift;
    my $relative_num = shift;
    my $footid = shift;
    my $docid = shift;
    my $from_file = shift;
    my $footnote_file = shift;
    my $lines = shift;
    my $state = shift;
 
    my $footnote_state = $Texi2HTML::THISDOC{'state'};
    my $footnote_info_state = info_default_get_state ($footnote_state);

    my $footnote_text = "($info_default_footnote_index)";
    my $node_name;
    $node_name = '';
    $node_name = $info_default_current_node->{'text'} if defined($info_default_current_node);
    if ($SEPARATED_FOOTNOTES)
    {
        $footnote_text .=  ' (' . info_default_normal_reference('pxref', ["${node_name}-Footnote-${info_default_footnote_index}"]) . ')';
    }
    push @info_default_pending_footnotes, {'lines' => $lines, 
         'footnote_text' => $footnote_text, 
         'footnote_index' => ${info_default_footnote_index}, 
         'node_name' => $node_name, 
         'footnote_info_state' => $footnote_info_state};
    return ($lines,  $footnote_text);
}

sub info_default_foot_lines($)
{
    my $lines = shift;
    #my $state = $Texi2HTML::THISDOC{'state'};
    #my $info_state = info_default_get_state ($state);
    @$lines = ();
}

sub info_default_format_list_item_texi($$$$)
{
    my $format = shift;
    my $line = shift;
    my $prepended = shift;
    my $command = shift;

    my $result_line;
    $prepended = "\@$command\{\}" if (defined($command) and $command ne '');
 
    if (defined($prepended) and $prepended ne '')
    {
         $prepended =~ s/^\s*//;
         $prepended =~ s/\s*$//;
         $line =~ s/^\s*//;
         $result_line = $prepended . ' ' . $line;
    }
    return ($result_line, 0);
}

sub info_default_list_item($$$$$$$$$$$)
{
    my $text = shift;
    my $format = shift;
    my $command = shift;
    my $formatted_command = shift;
    my $item_nr = shift;
    my $enumerate_style = shift;
    my $number = shift;
    my $prepended = shift;
    my $prepended_formatted = shift;
    my $only_inter_item_commands = shift;
    my $before_items = shift;

#    my $prepend = '';
#    if (defined($formatted_command) and $formatted_command ne '')
#    {
#        $prepend = $formatted_command;
#    }
#    return $prepend . $text;
    return $text;
}

sub info_default_format($$$)
{
    my $tag = shift;
    my $element = shift;
    my $text = shift;
    #return '' if (!defined($element) or ($text !~ /\S/));
    #return $text if ($element eq '');
    $element = undef if ($element eq '');
    my $element_end = $element;
    if ($element =~ /^(\w+)(\s+)(.+)/)
    {
        $element = $1;
        $element_end = $2;
    }
    return info_default_close_command(undef, undef, $tag, undef, undef, undef, $element, undef, $element_end);
}

sub info_default_tab_item_texi($$$$$$)
{
   my $command = shift;
   my $commands_stack = shift;
   my $stack = shift;
   my $state = shift;
   my $line = shift;
   my $line_nr = shift;

   my $format;
   $format = $commands_stack->[-1] if (defined($commands_stack) and @$commands_stack and $commands_stack->[-1]);
print STDERR "tab_item_texi $command $commands_stack, $stack, $state, $line, $line_nr\n";
   info_default_store_text ($state, '', $command, {'format' => $format});
   return undef;
}

1;
